# ------------------------------------------------------------------
# Решение системы линейных алгебраических уравнений (СЛАУ)
#     A*x = b
# методом сопряжённых градиентов.
#
# Реализация №0: Последовательный алгоритм решения СЛАУ.
#                Однако параллелизация происходит за счёт внутренней
#                параллелизации матричных операций в библиотеках
#                `numpy` или `cupy`.
# ------------------------------------------------------------------
# Эта реализация детально разбирается в примере
# mpi_toolkit/examples/Example-03-0.py
# ------------------------------------------------------------------

from ..cpu_timer import BenchmarkTimer
from .solver_base import SolverBase


# =============================================================================
class SolverSequential(SolverBase):
    """
    Решалка, реализующая последовательное решение системы
    линейных уравнений `A*x = b` методом сопряжённых градиентов.

    :param numpy_lib: Ссылка на библиотеку `numpy`, которую
                      нужно использовать для вычислений
                      (это может быть как `numpy`, так и `cupy`).

    :return: Приближённое (или точное, для квадратной матрицы) решение
             системы уравнений в виде полного вектора `x`.
    """
    def __init__(self, numpy_lib=None):
        super().__init__(numpy_lib)

    def _conjugate_gradient_method(self, A, b, x):
        """
        Последовательное решение системы линейных уравнений A*x = b
        методом сопряжённых градиентов.

        :param A: Полная матрица `A` с размером M x N.
        :param b: Полный вектор `b` с размером M.
        :param x: Полный вектор `x` с размером N.

        :return: Приближённое (или точное, для квадратной матрицы) решение
                 системы уравнений в виде полного вектора `x`.
        """
        if self._rank != 0:
            return None

        if self._skip_init_time:
            self._timer_calc.start()

        np = self._numpy_lib
        M, N = A.shape

        timer = BenchmarkTimer()
        timer.is_active = self._verbose

        timer.start('ALL')
        timer.start('serial')
        # Сделаем "хранилища" для полных векторов `p`, `r`, и `q`
        # на всех процессах. Вектор `p` сразу инициализируем
        # нулём (на итерации s=0):
        p = np.zeros(N, dtype=np.float64)
        r = np.empty(N, dtype=np.float64)
        q = np.empty(N, dtype=np.float64)

        # Чтобы сэкономить одно скалярное произведение векторов `p` и `q`
        # На каждой итерации, введём здесь временную переменную для него:
        dot_pq = 0.0
        timer.stop('serial')

        # Цикл по итерациям s от 1 до N включительно:
        for s in range(1, N + 1):
            # ------------------------------------------------------------
            # Шаг 1:
            # Обновим или создадим вектор `r`.
            if s == 1:
                # На первой итерации s=1, нужно создать вектор `r`:
                #   r_{s} = A.T.dot(A.dot(x_{s}) - b)
                timer.start('parallel')
                r = np.dot(A, x) - b
                if not self._is_symmetric:
                    r = np.dot(A.T, r)
                if self._alpha != 0.0:
                    r = r + self._alpha * x
                timer.stop('parallel')
            else:
                # На всех последующих итерациях, вектор `r` нужно просто
                # обновить:
                #    dot_pq = dot(p_{s-1}, q_{s-1})
                #    r_{s} = r_{s-1} - q_{s-1} / dot_pq

                # Важно, что скалярное произведение `dot(p_{s-1}, q_{s-1})`
                # мы уже вычислили в самом конце предыдущей итерации
                # и поместили его в переменную `dot_pq`, где оно до сих
                # пор ещё и хранится. Просто воспользуемся им для обновления `r`:
                timer.start('serial')
                r = r - q / dot_pq
                timer.stop('serial')

            # ------------------------------------------------------------
            # Шаг 2:
            # Обновим вектор `p`:
            #    dot_rr = dot(r_{s}, r_{s})
            #    p_{s} = p_{s-1} + r_{s} / dot_rr
            timer.start('serial')
            p = p + r / np.dot(r, r)
            timer.stop('serial')

            # ------------------------------------------------------------
            # Шаг 3:
            # Обновим вектор `q`:
            #    q_{s} = A.T.dot(A.dot(p_{s}))
            timer.start('parallel')
            q = np.dot(A, p)
            if not self._is_symmetric:
                q = np.dot(A.T, q)
            if self._alpha != 0.0:
                q = q + self._alpha * p
            timer.stop('parallel')

            # ------------------------------------------------------------
            # Шаг 4:
            # Посчитаем скалярное произведение векторов dot(p, q):
            #    dot_pq = dot(p_{s}, q_{s})

            timer.start('serial')
            # Запишем это скалярное произведение в переменную `dot_pq` -
            # оно будет переиспользовано в начале цикла для обновления
            # вектора `r`:
            dot_pq = np.dot(p, q)

            # ------------------------------------------------------------
            # Шаг 5:
            # Обновим вектор `x`:
            #    x_{s+1} = x_{s} - p_{s} / dot_pq
            x = x - p / dot_pq
            timer.stop('serial')
        timer.stop('ALL')

        if self._verbose:
            timer.print_status()

        return x

# =============================================================================
