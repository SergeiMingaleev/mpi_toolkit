from mpi4py import MPI

from ..config import config

# Работаем с коммуникатором по всем доступным процессам:
comm = MPI.COMM_WORLD
comm_size = comm.Get_size()
comm_rank = comm.Get_rank()


# =============================================================================
def matrix_Hilbert(M, N=None, rank=0, numpy_lib=None):
    """
    Создаёт матрицу Гильберта (Hilbert matrix) с размером MxN элементов.
    По определению (https://ru.wikipedia.org/wiki/Матрица_Гильберта),
    такая матрица состоит из элементов:
        A_{ij} = 1/(i+j+1)
    где i=0..M и j=0..N.

    Квадратная матрица Гильберта (M==N) представляет собой знаменитый пример
    плохо обусловленной матрицы с числом обусловленности:
        cond(A) = |A|*|A^{-1}| ~ (1+sqrt(2))^{4N}/sqrt(N) ~ exp(3.5*N)/sqrt(N)
    Как известно (https://ru.wikipedia.org/wiki/Число_обусловленности),
    такой экспоненциально быстрый рост числа обусловленности матрица приводит
    к быстро нарастающим ошибкам численного округления при решении системы
    линейных уравнений A*x = b.
    Именно, относительная неточность dA в задании матрицы A приводит к росту
    относительной неточности dx решения x с коэффициентом равным
    cond(A) / (1 - cond(A)*dA).

    В то же время, квадратная матрица Гильберта (M==N) является симметричной
    вполне положительно определённой матрицей, так что система уравнений
    A*x=b всегда имеет решение. В сочетании с плохой обусловленностью это
    делает матрицу Гильберта хорошим тестовым примером для проверки разных
    алгоритмов решения систем линейных уравнений на их вычислительную устойчивость.
    """
    N = M if N is None else N
    if M < 1 or N < 1:
        raise ValueError("Matrix size must be one or greater")

    if numpy_lib is None:
        # Нельзя больше изменять `config.numpy_lib`:
        config.lock()
        numpy_lib = config.numpy_lib

    if rank != comm_rank:
        return None

    if M == 1 and N == 1:
        return numpy_lib.array([[1]])

    v = numpy_lib.arange(1, N + 1) + numpy_lib.arange(0, M)[:, numpy_lib.newaxis]
    return 1.0 / v


# =============================================================================
def matrix_TridiagThermal(M, N=None, b=0.05, rank=0, numpy_lib=None):
    """
    Создаёт трёхдиагональную матрицу с размером MxN элементов,
    которая возникает (для случая M==N) при решении одномерного
    уравнения теплопроводности в однородной среде.

    Все элементы на верхней и нижней диагоналях такой матрицы
    будут равны -b, где значение положительного числа b задаётся
    аргументом `b` данной функции.

    Все элементы на главной диагонали такой матрицы будут равны
    a = 1 + 2*b

    Если матрица не квадратная (M>N), то все три диагонали повторяются
    на нижних строках матрицы таким образом, чтобы она не становилась
    вырожденной (при этом матрица `A.T.dot(A)` выглядит в моих тестах
    хорошо обусловленной).

    Квадратная матрица (M==N) такого рода является симметричной
    вполне положительно определённой матрицей и притом хорошо
    обусловленной - решение системы линейных уравнений A*x = b
    всегда существует и легко находится даже простейшим вариантом
    метода Гаусса. Это делает такую матрицу хорошим тестовым
    примером для проверки разных алгоритмов решения систем линейных
    уравнений на их производительность безотносительно к
    вычислительной устойчивости.
    """
    N = M if N is None else N
    if M < 2 or N < 2:
        raise ValueError("Matrix size must be 2 or greater")

    if numpy_lib is None:
        # Нельзя больше изменять `config.numpy_lib`:
        config.lock()
        numpy_lib = config.numpy_lib

    if rank != comm_rank:
        return None

    mat = numpy_lib.zeros((M, N))
    # Главная диагональ:
    a = 1.0 + 2.0*b
    numpy_lib.fill_diagonal(mat, a, wrap=True)
    # Верхняя диагональ:
    numpy_lib.fill_diagonal(mat[:, 1:], -b, wrap=True)
    # Нижняя диагональ:
    numpy_lib.fill_diagonal(mat[1:, :], -b, wrap=True)

    return mat

# =============================================================================
