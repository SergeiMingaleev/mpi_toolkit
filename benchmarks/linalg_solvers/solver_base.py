# ------------------------------------------------------------------
# Решение системы линейных алгебраических уравнений (СЛАУ)
#     A*x = b
# методом сопряжённых градиентов.
#
# Базовый класс.
# ------------------------------------------------------------------

from mpi4py import MPI
from .cpu_timer import StopwatchTimer


# =============================================================================
class SolverBase:
    """
    Базовый класс решалки системы линейных уравнений A*x = b
    методом сопряжённых градиентов.
    """
    def __init__(self, numpy_lib=None):
        if numpy_lib is None:
            import numpy as numpy_lib
        self._numpy_lib = numpy_lib

        # Настроим MPI:
        self._comm = MPI.COMM_WORLD
        self._P = self._comm.Get_size()
        self._rank = self._comm.Get_rank()

        self._verbose = False
        self._duration = None
        self._M = self._N = None
        self._is_symmetric = False
        self._alpha = 0.0

    def calc(self, A, b, x, is_symmetric=False, alpha=0.0,
             verbose=False, skip_init_time=True):
        """
        Решает заданную систему линейных уравнений A*x = b
        методом сопряжённых градиентов.

        :param A: Полная матрица `A` с размером M x N.
        :param b: Полный вектор `b` с размером M.
        :param x: Полный вектор `x` с размером N.
                  Задаёт начальное приближение к решению.
        :param is_symmetric: Является ли матрица симметричной?
                             Если да, то её не нужно умножать
                             на транспонированную матрицу.
        :param alpha: Параметр регуляризации по методу Тихонова.
        :param verbose: Нужно ли при вычислениях собирать
                        и печатать статистику по скорости
                        выполнения отдельных шагов алгоритма?

        :return: Решение - вектор `x`.
        """
        self._M = self._N = None
        if self._rank == 0:
            self._M, self._N = A.shape
        self._is_symmetric = is_symmetric
        self._alpha = alpha
        self._verbose = verbose
        self._skip_init_time = skip_init_time
        self._timer_calc = StopwatchTimer()
        if not self._skip_init_time:
            self._timer_calc.start()
        x = self._conjugate_gradient_method(A, b, x)
        self._timer_calc.stop()
        self._duration = self._timer_calc.duration()

        return x

    @property
    def duration(self):
        return self._duration

    @property
    def GFlops(self):
        """
        Рассчитывает производительность (в единицах GFlops)
        последнего вызова метода `calc()` для решения системы
        линейных уравнений A*x = b.

        :return: GFlop / second.
        """
        return self.Flop / self.duration / 1e9

    @property
    def Flop(self):
        """
        Рассчитывает вычислительную сложность метода
        сопряжённых градиентов для решения системы
        линейных уравнений A*x = b.

        :return: Число Flop (floating point operations).
        """
        M, N = self._M, self._N

        # p_{0} = 0
        flop = N

        # for s in range(1, N+1):
        #     if s == 1:
        #         r_{s} = dot(A.T, dot(A, x_{s}) - b) + alpha * x_{s}
        flop += M * (2 * N - 1) + M
        if not self._is_symmetric:
            flop += N * (2 * M - 1)
        if self._alpha != 0.0:
            flop += 2 * N

        #     else:
        #         # This was already done at the previous iteration:
        #         #--> dot_pq = dot(p_{s-1}, q_{s-1})
        #         r_{s} = r_{s-1} - q_{s-1} / dot_pq
        flop += (N - 1) * 2 * N

        #     dot_rr = dot(r_{s}, r_{s})
        flop += N * (2 * N - 1)
        #     p_{s} = p_{s-1} + r_{s} / dot_rr
        flop += N * 2 * N
        #     q_{s} = dot(A.T, dot(A, p_{s})) + alpha * p_{s}
        flop += N * M * (2 * N - 1)
        if not self._is_symmetric:
            flop += N * N * (2 * M - 1)
        if self._alpha != 0.0:
            flop += N * 2 * N
        #     dot_pq = dot(p_{s}, q_{s})
        flop += N * (2 * N - 1)
        #     x_{s+1} = x_{s} - p_{s} / dot_pq
        flop += N * 2 * N

        return flop

    def _auxiliary_arrays_determination(self, M, P):
        """
        Расчёт списков числа элементов `rcounts` и соответствующих
        смещений "displs", определяющих распределение больших матриц
        и векторов по процессам MPI коммуникатора.

        :param M: Общее число элементов вдоль нужной оси матрицы.
        :param P: Общее число процессов, работающих над параллелизацией
                  вычислений. Предполагаем при этом, что поток 0 только
                  "дирижирует" работу, а "рабочие" потоки от 1 до P-1
                  её выполняют.
        :return: Рассчитанные списки числа элементов `rcounts` и
                 соответствующих смещений "displs", определяющие
                 передачу данных каждому процессу.
        """
        np = self._numpy_lib
        # Считая, что M = (P-1) * K + L, где K и L - это целые числа,
        # причём 0 <= L <= P-2, мы можем держать на каждом процессе
        # либо по K+1 либо по К строк, для максимальной балансировки памяти
        # и вычислений по всем "рабочим" процессам.
        # Найдём целые числа K и L из описания алгоритма выше:
        K, L = divmod(np.int32(M), P - 1)

        # Введём два новых списка для описания того, как именно
        # матрицы и векторы будут распределяться по всем процессам.
        # Здесь `rcounts` будет содержать число элементов, хранимое
        # каждым процессом (это 0 для процесса 0, K+1 для первых L
        # "рабочих" процессов, и K для оставшихся процессов).
        # Другой список `displs` будет содержать индекс смещений
        # - то есть, номер первой строки, начиная с которой будут
        # храниться `rcounts[m]` строк на процессе `m`.
        # При этом мы предполагаем, что все элементы, которые
        # хранятся на каждом процессе, идут подряд.
        rcounts = np.empty(P, dtype=np.int32)
        displs = np.empty(P, dtype=np.int32)

        # Процесс 0 не рабочий, и он будет содержать ноль элементов:
        rcounts[0] = displs[0] = 0

        # Цикл по всем "рабочим" процессам:
        for m in range(1, P):
            if m <= L:
                # Процессы от 1 до L содержат по K+1 строк матрицы
                # (если L=0, то таких процессов не будет!):
                rcounts[m] = K + 1
            else:
                # Оставшиеся процессы от L+1 до P-1 содержат по K строк:
                rcounts[m] = K
            # Индекс смещений сдвигается каждый раз на число
            # строк, хранимых в процессе:
            displs[m] = displs[m - 1] + rcounts[m - 1]
        return rcounts, displs

    # ------------------------------------------------------------------
    def _auxiliary_arrays_determination2(self, M, P):
        """
        Расчёт списков числа элементов `rcounts` и соответствующих
        смещений "displs", определяющих распределение больших матриц
        и векторов по всем процессам MPI коммуникатора, включая
        и процесс 0.

        :param M: Общее число элементов вдоль нужной оси матрицы.
        :param P: Общее число процессов вдоль нужной оси сетки процессов,
                  работающих над параллелизацией вычислений.
        :return: Рассчитанные списки числа элементов `rcounts` и
                 соответствующих смещений "displs", определяющие
                 передачу данных каждому процессу.
        """
        np = self._numpy_lib
        # Считая, что M = P * K + L, где K и L - это целые числа,
        # причём 0 <= L <= P-1, мы можем держать на каждом процессе
        # либо по K+1 либо по К строк, для максимальной балансировки
        # памяти и вычислений по всем "рабочим" процессам.
        # Найдём целые числа K и L из описания алгоритма выше:
        K, L = divmod(np.int32(M), P)

        # Введём два новых списка для описания того, как именно
        # матрицы и векторы будут распределяться по всем процессам.
        # Здесь `rcounts` будет содержать число элементов, хранимое
        # каждым процессом (это K+1 для первых L процессов,
        # и K для оставшихся процессов).
        # Другой список `displs` будет содержать индекс смещений
        # - то есть, номер первой строки, начиная с которой будут
        # храниться `rcounts[m]` строк на процессе `m`.
        # При этом мы предполагаем, что все элементы, которые
        # хранятся на каждом процессе, идут подряд.
        rcounts = np.empty(P, dtype=np.int32)
        displs = np.empty(P, dtype=np.int32)

        # Цикл по всем процессам (они все "рабочие"):
        for m in range(0, P):
            if m < L:
                # Процессы от 0 до L-1 содержат по K+1 строк матрицы
                # (если L=0, то таких процессов не будет!):
                rcounts[m] = K + 1
            else:
                # Оставшиеся процессы от L до P-1 содержат по K строк:
                rcounts[m] = K
            # Индекс смещений равен 0 для процесса 0 и сдвигается
            # для каждого следующего процесса на число строк,
            # хранимых в предыдущем процессе:
            if m == 0:
                displs[m] = 0
            else:
                displs[m] = displs[m - 1] + rcounts[m - 1]
        return rcounts, displs

    def _conjugate_gradient_method(self, A, b, x):
        raise NotImplementedError()

# =============================================================================
