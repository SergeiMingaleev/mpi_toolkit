#------------------------------------------------------------------
# Пример 3.0: Последовательное решение системы линейных уравнений
#             методом сопряжённых градиентов.
#
# Задача: найти вектор x, являющийся решением системы линейных
#         уравнений A*x = b.
#
# Решение системы линейных уравнений A*x = b методом сопряжённых
# градиентов требует выполнения N итераций, где N - это размер
# вектора x. На каждой итерации мы будем обновлять значение
# вектора x в виде последовательности приближённых решений x_{s}
# на итерациях s от 1 до N+1.
#
# Чтобы начать итерации, нам нужно взять какое-то начальное
# приближение для x_{1} на первой итерации - но в целом, оно может
# быть любым, и обычно начинают с нулевого значения.
#
# Нам также понадобятся три вспомогательных вектора r, p, и q,
# значения которых также будут обновляться на каждой итерации s
# в виде последовательностей r_{s}, p_{s}, и q_{s}.
# Считаем при этом, что вектор p инициализирован нулём до начала
# итераций (то есть, для s=0).
#
# Тогда решение системы линейных уравнений может быть найдено
# методом сопряжённых градиентов по такому алгоритму:
#
#    x_{1} = 0 # или ваше приближение для решения!
#    p_{0} = 0
#    for s in range(1, N+1):
#        if s == 1:
#            r_{s} = dot(A.T, dot(A, x_{s}) - b)
#        else:
#            dot_pq = dot(p_{s-1}, q_{s-1})
#            r_{s} = r_{s-1} - q_{s-1} / dot_pq
#        dot_rr = dot(r_{s}, r_{s})
#        p_{s} = p_{s-1} + r_{s} / dot_rr
#        q_{s} = dot(A.T, dot(A, p_{s}))
#        dot_pq = dot(p_{s}, q_{s})
#        x_{s+1} = x_{s} - p_{s} / dot_pq
#
# После выполнения этого алгоритма, мы получим приближённое
# решение x_{N+1}, которое для случая квадратной матрицы A будет
# в действительности точным решением (с точностью до ошибок
# численного округления при выполнении арифметических операций).
#
# Размер матрицы A равен (M, N) - M строк и N колонок.
#
# Реализация самого метода сопряжённых градиентов вынесена в функцию
# `conjugate_gradient_method()` - остальная же часть кода занимается
# подготовкой данных и визуализацией решения.
#
#------------------------------------------------------------------
# Этот пример (в его оригинальном виде) детально обсуждается
# в начале лекции Д.В. Лукьяненко "3. Параллельная реализация метода
# сопряжённых градиентов":
# https://youtu.be/rQz7xov3_rU?list=PLcsjsqLLSfNCxGJjuYNZRzeDIFQDQ9WvC
#
# Объяснения математической части самого метода сопряжённых
# градиентов даются в лекциях Д.В. Лукьяненко:
# Лекция 9. Методы минимизации:
# https://teach-in.ru/lecture/2021-06-10-Lukyanenko
# Лекция 26. Интегральные уравнения
# https://teach-in.ru/lecture/2021-12-03-Lukyanenko
#
#------------------------------------------------------------------
# ВАЖНО ЗНАТЬ:
# Вышеописанная форма метода сопряжённых градиентов была впервые
# предложена в 2011 году российскими математиками в статье:
# Н.Н. Калиткин, Л. . Кузьмина, “Улучшенная форма метода сопряженных
# градиентов”, Матем. моделирование, 23:7 (2011), 33–51
# https://www.mathnet.ru/mm3129
#------------------------------------------------------------------

import numpy as np
from cpu_timer import BenchmarkTimer


#------------------------------------------------------------------
def conjugate_gradient_method(A, b, x):
    """
    Последовательное решение системы линейных уравнений A*x = b
    методом сопряжённых градиентов.

    Вычислительная сложность этого алгоритма равна:
    4*M*N**2 + 9*N**2 + 3*M*N - 4*N + 1

    :param A: Полная матрица `A` с размером M x N.
    :param b: Полный вектор `b` с размером M.
    :param x: Полный вектор `x` с размером N.
    :param N: Размер полного вектора `x`.

    :return: Приближённое (или точное, для квадратной матрицы) решение
             системы уравнений в виде полного вектора `x`.
    """
    M, N = A.shape

    mpi_timer = BenchmarkTimer()
    mpi_timer.start('ALL')
    mpi_timer.start('serial')
    # Сделаем "хранилища" для полных векторов `p`, `r`, и `q`
    # на всех процессах. Вектор `p` сразу инициализируем 
    # нулём (на итерации s=0):
    p = np.zeros(N, dtype=np.float64)
    r = np.empty(N, dtype=np.float64)
    q = np.empty(N, dtype=np.float64)

    # Чтобы сэкономить одно скалярное произведение векторов `p` и `q`
    # На каждой итерации, введём здесь временную переменную для него:
    dot_pq = 0.0
    # Cost: N+1 Flop.
    mpi_timer.stop('serial')
    
    # Цикл по итерациям s от 1 до N включительно:
    for s in range(1, N + 1):
        #------------------------------------------------------------
        # Шаг 1:
        # Обновим или создадим вектор `r`.
        if s == 1:
            # На первой итерации s=1, нужно создать вектор `r`:
            #   r_{s} = A.T.dot(A.dot(x_{s}) - b)
            mpi_timer.start('parallel')
            r = np.dot(A.T, np.dot(A, x) - b)
            # Cost: (2M-1)*N + (2N-1)*M + M = 4NM - N Flop.
            mpi_timer.stop('parallel')
        else:
            # На всех последующих итерациях, вектор `r` нужно просто
            # обновить:
            #    dot_pq = dot(p_{s-1}, q_{s-1})
            #    r_{s} = r_{s-1} - q_{s-1} / dot_pq

            # Важно, что скалярное произведение `dot(p_{s-1}, q_{s-1})`
            # мы уже вычислили в самом конце предыдущей итерации
            # и поместили его в переменную `dot_pq`, где оно до сих
            # пор ещё и хранится. Просто воспользуемся им для обновления `r`:
            mpi_timer.start('serial')
            r = r - q / dot_pq
            # Cost: (N-1) * 2N Flop
            mpi_timer.stop('serial')

        #------------------------------------------------------------
        # Шаг 2:
        # Обновим вектор `p`:
        #    dot_rr = dot(r_{s}, r_{s})
        #    p_{s} = p_{s-1} + r_{s} / dot_rr
        mpi_timer.start('serial')
        p = p + r / np.dot(r, r)
        # Cost: N * (2N + 2N - 1) Flop
        mpi_timer.stop('serial')

        #------------------------------------------------------------
        # Шаг 3:
        # Обновим вектор `q`: 
        #    q_{s} = A.T.dot(A.dot(p_{s}))
        mpi_timer.start('parallel')
        q = np.dot(A.T, np.dot(A, p))
        # Cost: N * ((2M-1)*N + (2N-1)*M) Flop
        mpi_timer.stop('parallel')

        #------------------------------------------------------------
        # Шаг 4:
        # Посчитаем скалярное произведение векторов dot(p, q): 
        #    dot_pq = dot(p_{s}, q_{s})

        mpi_timer.start('serial')
        # Запишем это скалярное произведение в переменную `dot_pq` - 
        # оно будет переиспользовано в начале цикла для обновления 
        # вектора `r`:
        dot_pq = np.dot(p, q)
        # Cost: N * (2N-1) Flop

        #------------------------------------------------------------
        # Шаг 5:
        # Обновим вектор `x`:
        #    x_{s+1} = x_{s} - p_{s} / dot_pq
        x = x - p / dot_pq
        # Cost: N * 2N Flop
        mpi_timer.stop('serial')
    mpi_timer.stop('ALL')
    mpi_timer.print_status()

    dt = mpi_timer.duration('ALL')
    flop = 4*M*N**2 + 9*N**2 + 3*M*N - 4*N + 1
    print(f"Производительность: {flop/dt/1e9:.3f} GFlops")

    return x


# ------------------------------------------------------------------
# Начинаем выполнение программы:
# ------------------------------------------------------------------
if __name__ == '__main__':

    #------------------------------------------------------------------
    # Размер (M, N) матрицы A:

    M = 512
    N = 512
    #    24.3398 ms ( 66.726 %): parallel --    513 calls ==     0.04745 ms/call
    #    10.1565 ms ( 27.843 %): serial   --   1536 calls ==     0.00661 ms/call
    # Производительность: 14.804 GFlops

    # M = 1024
    # N = 1024
    #   314.1362 ms ( 89.038 %): parallel --   1025 calls ==     0.30647 ms/call
    #    32.9988 ms (  9.353 %): serial   --   3072 calls ==     0.01074 ms/call
    # Производительность: 12.209 GFlops

    # M = 2048
    # N = 2048
    # 5,350.4922 ms ( 97.524 %): parallel --   2049 calls ==     2.61127 ms/call
    #   118.5944 ms (  2.162 %): serial   --   6144 calls ==     0.01930 ms/call
    # Производительность: 6.272 GFlops

    # M = 4096
    # N = 4096
    # 49,821.1673 ms ( 98.971 %): parallel --   4097 calls ==    12.16040 ms/call
    #    466.4000 ms (  0.927 %): serial   --  12288 calls ==     0.03796 ms/call
    # Производительность: 5.465 GFlops

    # M = 16384 # == 4096 * 4
    # N = 2048  # == 4096//2
    # 50,633.1123 ms ( 99.586 %): parallel --   2049 calls ==    24.71113 ms/call
    #    183.2375 ms (  0.360 %): serial   --   6144 calls ==     0.02982 ms/call
    # Производительность: 5.409 GFlops

    # M = 65536 # == 16384 * 4
    # N = 1024  # == 2048//2
    # 46,190.5573 ms ( 99.787 %): parallel --   1025 calls ==    45.06396 ms/call
    #     85.4101 ms (  0.185 %): serial   --   3072 calls ==     0.02780 ms/call
    # Производительность: 5.943 GFlops

    # M = 262144 # == 65536 * 4
    # N = 512    # == 1024//2
    # 46,944.6430 ms ( 99.897 %): parallel --    513 calls ==    91.51003 ms/call
    #     41.6287 ms (  0.089 %): serial   --   1536 calls ==     0.02710 ms/call
    # Производительность: 5.858 GFlops

    # M = 1048576 # == 262144 * 4
    # N = 256     # == 512//2
    # 48,097.3531 ms ( 99.954 %): parallel --    257 calls ==   187.14923 ms/call
    #     19.0115 ms (  0.040 %): serial   --    768 calls ==     0.02475 ms/call
    # Производительность: 5.729 GFlops

    np.random.seed(17)

    A = np.random.rand(M, N)

    t = np.arange(1, N+1) / (N + 1)
    x = np.sin(2 * np.pi * t)

    b = np.dot(A, x)

    # Начальное приближение для `x`:
    # x = np.zeros(N, dtype=np.float64)
    x = 0.9*x

    #------------------------------------------------------------------
    x = conjugate_gradient_method(A, b, x)
    #------------------------------------------------------------------

    # Для контроля, напечатаем найденное решение на консоли:
    print(f"\nFinal solution:\nx = {x}")

    # Подготовим рисунок и данные для него:
    import matplotlib.pyplot as plt

    plt.style.use('dark_background')
    fig = plt.figure()
    ax = plt.axes(xlim=(0, N), ylim=(-1.5, 1.5))
    ax.set_xlabel('i'); ax.set_ylabel('x[i]')

    # индексы элементов вектора `x`:
    ii = np.arange(np.int32(N))

    # Нарисуем полученное нами выше полное решение:
    ax.plot(ii, x, '-y', lw=3, label='conj_grad (A)')
    plt.show()

#------------------------------------------------------------------
