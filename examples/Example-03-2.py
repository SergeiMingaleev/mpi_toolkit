#------------------------------------------------------------------
# Пример 3.2: Параллельное решение системы линейных уравнений
#             методом сопряжённых градиентов.
# Реализация №2: Пытаемся распараллелить только произведения матрицы
#                на вектор. Скалярные же произведения двух векторов
#                будут выполнять на каждом процессе независимо
#                (полностью повторяя одни и те же вычисления! -
#                но экономя время на пересылке частичных векторов
#                между процессами).
#
# Задача: найти вектор x, являющийся решением системы линейных
#         уравнений A*x = b, максимально эффективно параллелизуя
#         работу между процессами с использованием MPI интерфейса.
#
# Решение системы линейных уравнений A*x = b методом сопряжённых
# градиентов требует выполнения N итераций, где N - это размер
# вектора x. На каждой итерации мы будем обновлять значение
# вектора x в виде последовательности приближённых решений x_{s}
# на итерациях s от 1 до N+1.
#
# Чтобы начать итерации, нам нужно взять какое-то начальное
# приближение для x_{1} на первой итерации - но в целом, оно может
# быть любым, и обычно начинают с нулевого значения.
#
# Нам также понадобятся три вспомогательных вектора r, p, и q,
# значения которых также будут обновляться на каждой итерации s
# в виде последовательностей r_{s}, p_{s}, и q_{s}.
# Считаем при этом, что вектор p инициализирован нулём до начала
# итераций (то есть, для s=0).
#
# Тогда решение системы линейных уравнений может быть найдено
# методом сопряжённых градиентов по такому алгоритму:
#
#    x_{1} = 0 # или ваше приближение для решения!
#    p_{0} = 0
#    for s in range(1, N+1):
#        if s == 1:
#            r_{s} = dot(A.T, dot(A, x_{s}) - b)
#        else:
#            dot_pq = dot(p_{s-1}, q_{s-1})
#            r_{s} = r_{s-1} - q_{s-1} / dot_pq
#        dot_rr = dot(r_{s}, r_{s})
#        p_{s} = p_{s-1} + r_{s} / dot_rr
#        q_{s} = dot(A.T, dot(A, p_{s}))
#        dot_pq = dot(p_{s}, q_{s})
#        x_{s+1} = x_{s} - p_{s} / dot_pq
#
# После выполнения этого алгоритма, мы получим приближённое
# решение x_{N+1}, которое для случая квадратной матрицы A будет
# в действительности точным решением (с точностью до ошибок
# численного округления при выполнении арифметических операций).
#
# При параллелизации этого алгоритма мы будем считать, что общее
# число MPI процессов равно P.
# При этом процесс 0 будет занят исключительно синхронизацией
# данных между процессами, а реальная работа будет выполняться
# процессами от 1 до P-1 (будем называть их "рабочими" процессами).
#
# Размер матрицы A равен (M, N) - M строк и N колонок.
# Мы распределим эту матрицу между всеми "рабочими" процессами
# по строкам в форме массива A_part, как делалось в примере 1.1.
# Эта же матрица, но транспонированная (и при этом точно так же
# распределённая между процессами в форме тех же частей A_part),
# будет умножаться на векторы размером N, как делалось в примере 2.2.
#
# Скалярное произведение векторов будет выполняться на каждом
# процессе независимо! - для этого мы будем хранить полные
# копии векторов x, r, q, и p на каждом процессе.
#
# Реализация самого метода сопряжённых градиентов вынесена в функцию
# `conjugate_gradient_method()` - остальная же часть кода занимается
# подготовкой и пересылкой данных между MPI процессами.
#
#------------------------------------------------------------------
# Этот пример (в его оригинальном виде) детально обсуждается
# в лекции Д.В. Лукьяненко "3. Параллельная реализация метода
# сопряжённых градиентов":
# https://youtu.be/rQz7xov3_rU?list=PLcsjsqLLSfNCxGJjuYNZRzeDIFQDQ9WvC
#
# Объяснения математической части самого метода сопряжённых
# градиентов даются в лекциях Д.В. Лукьяненко:
# Лекция 9. Методы минимизации:
# https://teach-in.ru/lecture/2021-06-10-Lukyanenko
# Лекция 26. Интегральные уравнения
# https://teach-in.ru/lecture/2021-12-03-Lukyanenko
#
#------------------------------------------------------------------
# ВАЖНО ЗНАТЬ:
# Вышеописанная форма метода сопряжённых градиентов была впервые
# предложена в 2011 году российскими математиками в статье:
# Н.Н. Калиткин, Л. . Кузьмина, “Улучшенная форма метода сопряженных
# градиентов”, Матем. моделирование, 23:7 (2011), 33–51
# https://www.mathnet.ru/mm3129
#------------------------------------------------------------------

import numpy as np
from mpi4py import MPI


#------------------------------------------------------------------
def auxiliary_arrays_determination(M, P):
    """
    Расчёт списков числа элементов `rcounts` и соответствующих
    смещений "displs", определяющих распределение больших матриц
    и векторов по процессам MPI коммуникатора.

    :param M: Общее число элементов вдоль нужной оси матрицы.
    :param P: Общее число процессов, работающих над параллелизацией
              вычислений. Предполагаем при этом, что поток 0 только
              "дирижирует" работу, а "рабочие" потоки от 1 до P-1
              её выполняют.
    :return: Рассчитанные списки числа элементов `rcounts` и
             соответствующих смещений "displs", определяющие
             передачу данных каждому процессу.
    """
    # Считая, что M = (P-1) * K + L, где K и L - это целые числа,
    # причём 0 <= L <= P-2, мы можем держать на каждом процессе
    # либо по K+1 либо по К строк, для максимальной балансировки памяти
    # и вычислений по всем "рабочим" процессам.
    # Найдём целые числа K и L из описания алгоритма выше:
    K, L = divmod(np.int32(M), P - 1)

    # Введём два новых списка для описания того, как именно
    # матрицы и векторы будут распределяться по всем процессам.
    # Здесь `rcounts` будет содержать число элементов, хранимое
    # каждым процессом (это 0 для процесса 0, K+1 для первых L
    # "рабочих" процессов, и K для оставшихся процессов).
    # Другой список `displs` будет содержать индекс смещений
    # - то есть, номер первой строки, начиная с которой будут
    # храниться `rcounts[m]` строк на процессе `m`.
    # При этом мы предполагаем, что все элементы, которые
    # хранятся на каждом процессе, идут подряд.
    rcounts = np.empty(P, dtype=np.int32)
    displs = np.empty(P, dtype=np.int32)

    # Процесс 0 не рабочий, и он будет содержать ноль элементов:
    rcounts[0] = displs[0] = 0

    # Цикл по всем "рабочим" процессам:
    for m in range(1, P):
        if m <= L:
            # Процессы от 1 до L содержат по K+1 строк матрицы
            # (если L=0, то таких процессов не будет!):
            rcounts[m] = K + 1
        else:
            # Оставшиеся процессы от L+1 до P-1 содержат по K строк:
            rcounts[m] = K
        # Индекс смещений сдвигается каждый раз на число
        # строк, хранимых в процессе:
        displs[m] = displs[m - 1] + rcounts[m - 1]
    return rcounts, displs


#------------------------------------------------------------------
def conjugate_gradient_method(A_part, b_part, x, N):
    """
    Параллельное решение системы линейных уравнений A*x = b
    методом сопряжённых градиентов.

    Реализация №2: Пытаемся распараллелить только произведения матрицы
                   на вектор. Скалярные же произведения двух векторов
                   будут выполнять на каждом процессе независимо
                   (полностью повторяя одни и те же вычисления! -
                   но экономя время на пересылке частичных векторов
                   между процессами).

    Считаем, что на каждом процессе хранится только часть `A_part`
    матрицы `A`, разбитая между процессами по строкам.
    Также хранится только часть `b_part` вектора `b`.

    Полный вектор решения `x` имеет размер `N`, и его копия хранится
    на каждом процессе.

    :param A_part: Часть матрицы `A`, хранимая на текущем процессе.
                   Предполагается, что матрица `A` была разбита
                   между процессами по строкам.
    :param b_part: Часть вектора `b`, хранимая на текущем процессе.
    :param x:      Полный вектор `x` (его копия хранится на каждом процессе).
    :param N:      Размер полного вектора `x`.

    :return: Приближённое (или точное, для квадратной матрицы) решение
             системы уравнений в виде полного вектора `x`.
    """

    # Сделаем "хранилища" для полных векторов `p`, `r`, и `q`
    # на всех процессах. Вектор `p` сразу инициализируем 
    # нулём (на итерации s=0):
    p = np.zeros(N, dtype=np.float64)
    r = np.empty(N, dtype=np.float64)
    q = np.empty(N, dtype=np.float64)

    
    # Чтобы сэкономить одно скалярное произведение векторов `p` и `q`
    # На каждой итерации, введём здесь временную переменную для него:
    dot_pq = 0.0
    
    # Цикл по итерациям s от 1 до N включительно:
    for s in range(1, N + 1):
        #------------------------------------------------------------
        # Шаг 1:
        # Обновим или создадим вектор `r`.
        if s == 1:
            # Сначала, на первой итерации s=1, нужно создать вектор `r`:
            #   r_{s} = A.T.dot(A.dot(x_{s}) - b)

            # На каждом процессе мы можем собрать частично
            # просуммированный полный вектор `r` с размером N, поместив
            # эту часть в локальный для каждого процесса вектор `r_temp`:
            r_temp = np.dot(A_part.T, np.dot(A_part, x) - b_part)

            # И затем командой `comm.Allreduce` просуммировать
            # (суффикс `reduce`!) все `r_temp` на всех процессах, получив
            # полный вектор `r` и отдав его полную копию всем процессам
            # (префикс `All`!):
            comm.Allreduce([r_temp, N, MPI.DOUBLE],
                           [r, N, MPI.DOUBLE], op=MPI.SUM)
            # ВАЖНО: последняя команда пересылает *полный* вектор
            #        с размером N *всем* процессам - такая операция
            #        плохо масштабируется! В примере 5.1 мы это улучшим.
        else:
            # На всех последующих итерациях, вектор `r` нужно просто
            # обновить:
            #    dot_pq = dot(p_{s-1}, q_{s-1})
            #    r_{s} = r_{s-1} - q_{s-1} / dot_pq

            # Важно, что скалярное произведение `dot(p_{s-1}, q_{s-1})`
            # мы уже вычислили в самом конце предыдущей итерации
            # и поместили его в переменную `dot_pq`, где оно до сих
            # пор ещё и хранится. Просто воспользуемся им для обновления `r`:
            r = r - q / dot_pq

        #------------------------------------------------------------
        # Шаг 2:
        # Обновим вектор `p`:
        #    dot_rr = dot(r_{s}, r_{s})
        #    p_{s} = p_{s-1} + r_{s} / dot_rr
        p = p + r / np.dot(r, r)

        #------------------------------------------------------------
        # Шаг 3:
        # Обновим вектор `q`: 
        #    q_{s} = A.T.dot(A.dot(p_{s}))

        # На каждом процессе мы можем собрать частично просуммированный
        # полный вектор `q` с размером N, поместив эту часть в локальный
        # для каждого процесса вектор `q_temp`:
        q_temp = np.dot(A_part.T, np.dot(A_part, p))

        # И затем командой `comm.Allreduce` просуммировать
        # (суффикс `reduce`!) все `q_temp` на всех процессах, получив
        # полный вектор `q` и отдав его полную копию всем процессам
        # (префикс `All`!):
        comm.Allreduce([q_temp, N, MPI.DOUBLE],
                       [q, N, MPI.DOUBLE], op=MPI.SUM)
        # ВАЖНО: последняя команда пересылает *полный* вектор
        #        с размером N *всем* процессам - такая операция
        #        плохо масштабируется! В примере 5.1 мы это улучшим.

        #------------------------------------------------------------
        # Шаг 4:
        # Посчитаем скалярное произведение векторов dot(p, q): 
        #    dot_pq = dot(p_{s}, q_{s})

        # Запишем это скалярное произведение в переменную `dot_pq` - 
        # оно будет переиспользовано в начале цикла для обновления 
        # вектора `r`:
        dot_pq = np.dot(p, q)

        #------------------------------------------------------------
        # Шаг 5:
        # Обновим вектор `x`:
        #    x_{s+1} = x_{s} - p_{s} / dot_pq
        x = x - p / dot_pq

    return x


#------------------------------------------------------------------
# Начинаем выполнение программы - первым делом, настроим MPI:
#------------------------------------------------------------------

# Работаем с коммуникатором по всем доступным процессам:
comm = MPI.COMM_WORLD

# Число P доступных процессов в этом коммуникаторе:
P = comm.Get_size()

# Номер текущего процесса (от 0 до P-1):
rank = comm.Get_rank()

#------------------------------------------------------------------
# Шаг 0:
# Реализуемый алгоритм требует для работы хотя бы два MPI процесса -
# один будет командовать, а второй работать. Если процесс всего один,
# то работать просто некому!

if P == 1:
    raise ValueError(
        "\nAt least 2 MPI processes are needed to run this program!\n"
        "Please launch it with the command:\n"
        "mpiexec.exe -n * python.exe Example-03-2.py"
    )

#------------------------------------------------------------------
# Шаг 1 (точно такой же, как в примерах 1.1 и 2.2):
# Зачитаем из файла размер (M, N) матрицы A.
# Сделаем это только на процессе 0 - считаем,
# что входной файл доступен только на нём:

if rank == 0:
    with open('Example-03_in.dat', 'r') as f1:
        M = np.array(np.int32(f1.readline()))
        N = np.array(np.int32(f1.readline()))
else:
    # На "рабочих" процессах значение `M` не
    # используется - ставим пустую "заглушку":
    M = None
    # и подготавливаем на них "хранилище" для `N`:
    N = np.array(0, dtype=np.int32)

# Раздадим значение `N`, зачитанное процессом 0,
# всем остальным процессам (включая и сам процесс 0):
comm.Bcast(N, root=0)
# Альтернативно, более общая форма записи:
# comm.Bcast([N, 1, MPI.INT], root=0)

# NOTE: Значение `M` не используется на "рабочих" процессах,
#       так что мы его не будем раздавать - лишняя трата времени.

#------------------------------------------------------------------
# Шаг 2:
# Разберёмся, сколько из имеющихся M строк (и какие именно!)
# матрицы `A` и вектора `b` мы будем хранить в форме частичной
# матрицы `A_part` и частичного вектора `b_part` на каждом
# процессе - посчитаем для этого списки числа строк
# `rcounts_M` и их смещений `displs_M` (они объяснялись в
# примерах 1.1-2.2).

if rank == 0:
    # Сделаем такой анализ только на процессе 0.
    # Всю логику расчёта этих списков мы перенесём в отдельную
    # функцию `auxiliary_arrays_determination()`, определённую
    # выше в этом файле:
    rcounts_M, displs_M = auxiliary_arrays_determination(M, P)
else:
    # На "рабочих" процессах списки `rcounts_M` и `displs_M`
    # используются (в нескольких `comm.Scatterv` ниже) в качестве
    # пустых заглушек:
    rcounts_M = displs_M = None

# Подготовим "хранилище" для `M_part` на всех процессах:
M_part = np.array(0, dtype=np.int32)

# И разбросаем рассчитанные выше `rcounts_M` по всем процессам
# в виде одного значения `M_part = rcounts_M[m]` на каждом
# процессе `m`:
comm.Scatter([rcounts_M, 1, MPI.INT],
             [M_part, 1, MPI.INT], root=0)

#------------------------------------------------------------------
# Шаг 3:
# Зачитаем из файла матрицу `A`. Как и в примере 2.2, мы будем
# экономить память - будем зачитывать матрицу по кусочкам,
# сразу отдавая каждый кусочек нужному процессу.

# Подготовим "хранилище" для кусочков `A_part` на всех процессах -
# каждое со своим числом строк `M_part`:
A_part = np.empty((M_part, N), dtype=np.float64)
# NOTE: Поскольку на процессе 0 значение M_part равно нулю, то
# матрица `A_part` здесь будет пустой и не займёт памяти.

if rank == 0:
    # Зачитаем на процессе 0 файл с матрицей `A` не сразу весь,
    # а по кусочкам - сразу отдавая каждый кусочек своему
    # "рабочему" процессу (на процессе 0 при этом данных
    # матрицы `A` совсем не останется - экономим память!):
    with open('Example-03_AData.dat', 'r') as f2:
        for m in range(1, P):
            # Кусочек матрицы `A`, который мы отдадим процессу `m`:
            A_part_m = np.empty((rcounts_M[m], N), dtype=np.float64)
            # Зачитали данные:
            for j in range(rcounts_M[m]):
                for i in range(N):
                    A_part_m[j,i] = np.float64(f2.readline())
            # И сразу же отдали их процессу, причём с блокировкой (!):
            comm.Send([A_part_m, rcounts_M[m]*N, MPI.DOUBLE], dest=m, tag=0)

            # Может показаться, что более эффективной будет такая же,
            # но неблокирующая пересылка:
            #comm.Isend([A_part_m, rcounts_M[m]*N, MPI.DOUBLE], dest=m, tag=0)
            # Но её использование здесь приведёт к ошибке! - массив `A_part_m`
            # будет сразу же пересоздан в цикле по `m`, и нужные данные
            # в большинстве случаев просто не успеют переслаться процессу `m`.
            # (Поирайте с этим!)

            # Поможем сборщику мусора поскорее избавиться от больших
            # ненужных данных:
            del A_part_m
else:
    # Каждый "рабочий" процесс получает свою часть строк и записывает
    # их в свой массив `A_part` - опять с блокировкой:
    comm.Recv([A_part, M_part*N, MPI.DOUBLE], source=0, tag=0, status=None)

#------------------------------------------------------------------
# Шаг 4:
# Зачитаем из файла вектор `b`. Зачитаем его полностью на процессе 0
# (считаем, что входной файл доступен только на нём) - и потом
# раздадим его по кусочкам `b_part` всем "рабочим" процессам.

if rank == 0:
    # Зачитаем файл `b` на процессе 0:
    b = np.empty(M, dtype=np.float64)
    with open('Example-03_bData.dat', 'r') as f3:
        for j in range(M):
            b[j] = np.float64(f3.readline())
else:
    # На "рабочих" процессах вектор `b` используется
    # (в `comm.Scatterv` ниже) в качестве пустой заглушки:
    b = None

# Подготовим "хранилище" для `b_part` на всех процессах:
b_part = np.empty(M_part, dtype=np.float64)

# И разбросаем зачитанный выше вектор `b` по всем процессам m
# в виде кусочков `b_part` с размерами `M_part = rcounts_M[m]`,
# используя смещения `displs_M[m]`:
comm.Scatterv([b, rcounts_M, displs_M, MPI.DOUBLE], 
              [b_part, M_part, MPI.DOUBLE], root=0)

#------------------------------------------------------------------
# Шаг 5:
# Подготовим вектор `x` - его полная версия вектора будет храниться
# на каждом процессе.

# ВАЖНО: если вы знаете хорошее начальное приближение для `x`,
# дайте его здесь!
x = np.zeros(N, dtype=np.float64)

#------------------------------------------------------------------
# Шаг 6:
# Собственно, и сама нужная нам работа - решение системы линейных
# уравнений итерационным методом сопряжённых градиентов:

# На каждом процессе, алгоритм отработает со своими кусками массивов
# `A` и `b` в виде `A_part` и `b_part`, но возвратит полное решение `x`
# (детали описаны внутри самой функции):
x = conjugate_gradient_method(A_part, b_part, x, N)

# Проверим, кто что посчитал:
#print(f"x on process {rank} = {x}")

#------------------------------------------------------------------
# Шаг 7:
# Окончательно, нарисуем посчитанный вектор `x`, используя
# библиотеку matplotlib. Делаем это только на процессе 0.

if rank == 0:
    # Для контроля, напечатаем найденное решение на консоли:
    print(f"\nFinal solution:\nx = {x}")

    # Подготовим рисунок и данные для него:
    import matplotlib.pyplot as plt
    plt.style.use('dark_background')
    fig = plt.figure()
    ax = plt.axes(xlim=(0, N), ylim=(-1.5, 1.5))
    ax.set_xlabel('i'); ax.set_ylabel('x[i]')
    # индексы элементов вектора `x`:
    ii = np.arange(np.int32(N))
    # Нарисуем полное решение:
    ax.plot(ii, x, '-y', lw=3)
    plt.show()

#------------------------------------------------------------------
