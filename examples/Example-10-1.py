#------------------------------------------------------------------
# ИЗУЧИТЬ:
# -- Вспоминаем реализацию "явной" схемы метода конечных разностей
#    для решения двумерного ДУЧП параболического типа:
#    https://teach-in.ru/lecture/2021-12-15--Lukyanenko
# -- Сравниваем функции `fast_pde_solution()` и `slow_pde_solution()`.
#    Первая функция отличается только использованием "срезов"
#    в массивах библиотеки `numpy` вместо циклов по индексу `n`,
#    что позволяет ускорить вычисления в ~50 раз (и более,
#    для больших значений `Nx` и `Ny`).
# -- Если не помните, как 2D разностные схемы анализируются на
#    устойчивость, посмотрите неплохой вывод от ИИ на странице:
#    https://share.google/aimode/xvud7ghTqozpU3OUM
#------------------------------------------------------------------
# Пример 10.1: Последовательное решение двумерного (2D)
#              дифференциального уравнения в частных производных
#              (ДУЧП) параболического типа с использованием
#              "явной" схемы метода конечных разностей.
#
# Задача: найти решение уравнения:
#            du/dt = eps*(d^2 u/dx^2 + d^2 u/dy^2)
#                  + u*(du/dx + du/dy) + u^3
#         где `eps` - это некоторая константа, а `u(x,t)` - это
#         функция от времени `t` и двух пространственных
#         координат, `x` и `y`. Считаем, что эта функция определена
#         на интервале по `x` от `a` до `b`, на интервале по `y`
#         от `c` до `d` и на интервале по времени от `t0` до `T`.
#
# Для решения такой задачи нам нужно дополнительно знать начальное
# и граничные условия. Будем считать, что в начальный момент времени
# значения этой функции определяются начальным условием:
#    u(x, y, t0) = u_init(x, y)
# где функция `u_init(x, y)` определяется ниже в этом файле.
# Также считаем, что значения функции на границах `x=a` и `x=b`
# и границах `y=c` и `y=d` определяются граничными условиями:
#    u(a, y, t) = u_left(y, t)
#    u(b, y, t) = u_right(y, t)
#    u(x, c, t) = u_bottom(x, t)
#    u(x, d, t) = u_top(x, t)
# где функции `u_left(y, t)`, `u_right(y, t)`, `u_bottom(x, t)`,
# и `u_top(x, t)` также определяется ниже в этом файле.
#
# Для решения уравнения будем использовать метод конечных разностей,
# разбивая диапазон [t0, T] по времени на `M` интервалов, диапазон
# [a, b] по оси `x` на `Nx` интервалов, и диапазон [c, d] по оси `y`
# на `Ny` интервалов.
#
# Для простоты реализации, в этом примере мы будем использовать
# "явную" разностную схему решения уравнения, которая обладает
# первым порядком точности по времени и вторым порядком точности
# по пространственным координатам:
#    error ~ O(dt, dx^2, dy^2)
# где `dt = (T-t0) / M` - это шаг по времени `t`,
# `dx = (b-a) / Nx` - это шаг по координате `x`,
# `dy = (d-c) / Ny` - это шаг по координате `y`.
#
# Такая "явная" схема является условно устойчивой
# (любопытства ради, смотри неплохой вывод от ИИ на странице:
# https://share.google/aimode/xvud7ghTqozpU3OUM)
# только при выполнении жёсткого условия на максимальный
# шаг по времени:
#    dt * eps * (1/dx^2 + 1/dy^2) < 0.5
# что приводит к требованию, что число интервалов по времени `M` должно
# расти как квадрат числа интервалов по пространству `Nx` и `Ny`:
# M ~ Nx^2 + Ny^2.
# То есть, при увеличении `Nx` и `Ny` в 10 раз, нужно увеличить
# `M` в сто раз!
#
#------------------------------------------------------------------
# Этот пример (в его оригинальном виде "Example-10-1-consecutive.py")
# детально обсуждается в лекции Д.В. Лукьяненко "10. Решение задач
# для уравнений в частных производных. Ч.3", начиная с 13-й минуты:
# https://youtu.be/I8BWCH2fVDU?list=PLcsjsqLLSfNCxGJjuYNZRzeDIFQDQ9WvC&t=806
#
# Объяснения математической части разностных методов для решения
# такого уравнения даётся в лекции Д.В. Лукьяненко
# "Лекция 27. Уравнения в частных производных: многомерные уравнения":
# https://teach-in.ru/lecture/2021-12-15--Lukyanenko
#------------------------------------------------------------------

import time
import argparse
import numpy as np

try:
    # Добавим цветной вывод для WARNING:
    import colorama
    colorama.init(autoreset=True)
except ModuleNotFoundError:
    colorama = None


#------------------------------------------------------------------
def unit_array(vec1, vec2):
    if np.isscalar(vec1) and np.isscalar(vec2):
        return 1.0
    if np.isscalar(vec1):
        vec1 = np.array([vec1])
    if np.isscalar(vec2):
        vec2 = np.array([vec2])
    res = np.ones((len(vec1), len(vec2)))
    return res


#------------------------------------------------------------------
def u_init(x, y):
    """
    Функция, определяющая начальное условие для u(x, y, t):
               u(x, y, t0) = u_init(x, y)
    :param x: Значение пространственной координаты `x`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :param y: Значение пространственной координаты `y`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(x, y, t0)`.
    """
    if not np.isscalar(x) and not np.isscalar(y):
        x, y = np.meshgrid(x, y)
        x = x.T
        y = y.T
    res = 0.5*np.tanh(((x - 0.5)**2 + (y - 0.5)**2 - 0.35**2)/eps) - 0.17
    return res


#------------------------------------------------------------------
def u_left(y, t):
    """
    Функция, определяющая граничное условие для u(x, y, t)
    слева, в точке `x=a`:
               u(a, y, t) = u_left(y, t)
    :param y: Значение пространственной координаты `y`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :param t: Значение момента времени `t`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(a, y, t)`.
    """
    res = (1.0 / 3.0) * unit_array(t, y)
    return res


#------------------------------------------------------------------
def u_right(y, t):
    """
    Функция, определяющая граничное условие для u(x, y, t)
    справа, в точке `x=b`:
               u(b, y, t) = u_right(y, t)
    :param y: Значение пространственной координаты `y`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :param t: Значение момента времени `t`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(b, y, t)`.
    """
    res = (1.0 / 3.0) * unit_array(t, y)
    return res


#------------------------------------------------------------------
def u_top(x, t):
    """
    Функция, определяющая граничное условие для u(x, y, t)
    сверху, в точке `y=d`:
               u(x, d, t) = u_top(x, t)
    :param x: Значение пространственной координаты `x`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :param t: Значение момента времени `t`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(x, d, t)`.
    """
    res = (1.0 / 3.0) * unit_array(t, x)
    return res


#------------------------------------------------------------------
def u_bottom(x, t):
    """
    Функция, определяющая граничное условие для u(x, y, t)
    снизу, в точке `y=c`:
               u(x, c, t) = u_bottom(x, t)
    :param x: Значение пространственной координаты `x`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :param t: Значение момента времени `t`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(x, c, t)`.
    """
    res = (1.0 / 3.0) * unit_array(t, x)
    return res


#------------------------------------------------------------------
def slow_pde_solution():
    """
    Медленная реализация "явной" разностной схемы - основана
    на использовании медленного цикла по отдельным элементам.
    """
    # Используемые глобальные переменные (определяем их здесь
    # вместо передачи в качестве аргументов функции):
    global M, Nx, Ny, u, eps_dt_dx2, eps_dt_dy2, dt_2dx, dt_2dy, dt

    # Цикл по всем моментам времени:
    for m in range(M):
        # Первые и последние элементы не обновляются -
        # они определяются граничными условиями:
        for i in range(1, Nx):
            for j in range(1, Ny):
                u[m + 1, i, j] = u[m, i, j] + \
                                 eps_dt_dx2 * (u[m, i+1, j] - 2*u[m, i, j] + u[m, i-1, j]) + \
                                 eps_dt_dy2 * (u[m, i, j+1] - 2*u[m, i, j] + u[m, i, j-1]) + \
                                 dt_2dx * u[m, i, j] * (u[m, i+1, j] - u[m, i-1, j]) + \
                                 dt_2dy * u[m, i, j] * (u[m, i, j+1] - u[m, i, j-1]) + \
                                 dt * u[m, i, j]**3


#------------------------------------------------------------------
def fast_pde_solution():
    """
    Быстрая реализация "явной" разностной схемы - основана
    на использовании "срезов" вместо цикла по отдельным элементам.
    """
    # Используемые глобальные переменные (определяем их здесь
    # вместо передачи в качестве аргументов функции):
    global M, Nx, Ny, u, eps_dt_dx2, eps_dt_dy2, dt_2dx, dt_2dy, dt

    # Цикл по всем моментам времени:
    for m in range(M):
        # Первые и последние элементы не обновляются -
        # они определяются граничными условиями:
        u[m+1, 1:-1, 1:-1] = u[m, 1:-1, 1:-1] + \
                 eps_dt_dx2 * (u[m, 2:, 1:-1] - 2*u[m, 1:-1, 1:-1] + u[m, :-2, 1:-1]) + \
                 eps_dt_dy2 * (u[m, 1:-1, 2:] - 2*u[m, 1:-1, 1:-1] + u[m, 1:-1, :-2]) + \
                 dt_2dx * u[m, 1:-1, 1:-1] * (u[m, 2:, 1:-1] - u[m, :-2, 1:-1]) + \
                 dt_2dy * u[m, 1:-1, 1:-1] * (u[m, 1:-1, 2:] - u[m, 1:-1, :-2]) + \
                 dt * u[m, 1:-1, 1:-1]**3


#------------------------------------------------------------------
# Начинаем выполнение программы - включаем таймер:
#------------------------------------------------------------------
start_time1 = time.perf_counter()

#------------------------------------------------------------------
# Шаг 0:
# Распарсим аргументы запуска программы.

parser = argparse.ArgumentParser(
            prog='python Example-10-1.py',
            description='Решение 2D ДУЧП параболического типа с использованием '
                        '"явной" разностной схемы без MPI параллелизации.',
)
parser.add_argument('-Nx', default=100,
                    help='Число `Nx` интервалов сетки по координате `x`. '
                         'По умолчанию равно 100.')
parser.add_argument('-Ny', default=100,
                    help='Число `Ny` интервалов сетки по координате `y`. '
                         'По умолчанию равно 100.')
parser.add_argument('-M', default=2000,
                    help='Число `M` интервалов сетки по времени `t`. '
                         'По умолчанию равно 2000.')
parser.add_argument('-T', default=5.0,
                    help='Максимальное время `T`, до которого должны проводиться '
                         'расчёты. По умолчанию равно 5.0.')
parser.add_argument('--slow', action="store_true",
                    help='Использовать медленную реализацию решения, '
                         'с циклом по `i` и `j` при обновлении `u[m,i,j]` '
                         'вместо использования срезов `u[m,:,:]`.')
parser.add_argument('--noheader', action="store_true",
                    help='Не печатать названия колонок в выводе времени счёта.')
parser.add_argument('--save', action="store_true",
                    help='Сохранить результаты расчётов для последнего момента '
                         'времени в файл "Example-10-1_Results.npz".')
parser.add_argument('--saveall', action="store_true",
                    help='Сохранить результаты расчётов для всех моментов '
                         'времени в файл "Example-10-1_Results_all.npz".')
parser.add_argument('--plot', action="store_true",
                    help='Нарисовать решение для последнего момента времени.')

args = parser.parse_args()

#------------------------------------------------------------------
# Шаг 1:
# Задаём значения для всех констант, определяемых условиями задачи.
eps = 10**(-1.0)
a = -2.0; b = 2.0
c = -2.0; d = 2.0
t_0 = 0.0

T = float(args.T)
Nx = int(args.Nx)
Ny = int(args.Ny)
M = int(args.M)

#------------------------------------------------------------------
# Шаг 2:
# Находим значения для всех вспомогательных констант.

# Шаг по пространству:
dx = (b - a) / Nx
dy = (d - c) / Ny

# Шаг по времени:
dt = (T - t_0) / M

# Константы для "быстрого" использования внутри разностной схемы:
eps_dt_dx2 = eps * dt / dx**2
eps_dt_dy2 = eps * dt / dy**2
dt_2dx = dt / (2 * dx)
dt_2dy = dt / (2 * dy)

# Условие устойчивости "явной" разностной схемы
#    dt * eps * (1/dx^2 + 1/dy^2) < 0.5
# соответсвтует условию
#   eps_dt_dx2 + eps_dt_dy2 < 0.5
# Проверим его:
msg = None
stability_factor = eps_dt_dx2 + eps_dt_dy2
if stability_factor >= 0.5:
    msg = f'WARNING: Нарушено условие устойчивости "явной" разностной схемы: ' + \
          f'eps*dt*(1/dx^2 + 1/dy^2) = {stability_factor:.3f} (а должно быть меньше 0.5!).'
    # Выведем это предупреждение ярко-красным:
    msg = msg if colorama is None else colorama.Fore.LIGHTRED_EX + msg
    print(msg)

# Массивы для хранения точек используемой сетки по пространству:
x = np.linspace(a, b, Nx+1)
y = np.linspace(c, d, Ny+1)
# и по времени:
t = np.linspace(t_0, T, M+1)

#------------------------------------------------------------------
# Шаг 3:
# Задаём начальное и граничные условия.

# Будем хранить все насчитанные данные (для создания анимации):
u = np.empty((M + 1, Nx + 1, Ny + 1))

# Начальное условие:
u[0, :, :] = u_init(x, y)

# Граничные условия:
u[:, 0, :] = u_left(y, t)
u[:, Nx, :] = u_right(y, t)
u[:, :, 0] = u_bottom(x, t)
u[:, :, Ny] = u_top(x, t)

#------------------------------------------------------------------
# Шаг 4:
# Собственно, и сама нужная нам работа - решение нашего уравнения
# с помощью "явной" разностной схемы. По умолчанию, решаем уравнение
# быстро, но через переключатель '--slow' решаем медленно, как это
# было сделано в оригинальной версии программы. Сравните код обеих
# функций, `slow_pde_solution()` и `fast_pde_solution()`.
# Обратите внимание, что хотя эти функции вызываются без аргументов,
# они переиспользуют многие из введённых выше переменных как глобальные
# переменные (все такие переменные указаны в функциях как `global`).

start_time2 = time.perf_counter()

if args.slow:
    slow_pde_solution()
else:
    fast_pde_solution()

end_time = time.perf_counter()

#------------------------------------------------------------------
# Шаг 5:
# Печатаем время выполнения и, если нужно, сохраняем результаты
# расчётов в файл и/или рисуем график решения.

P = 1  # Число процессов, решающих уравнение.
duration1 = end_time - start_time1
duration2 = end_time - start_time2

if not args.noheader:
    print('Nx\t Ny\t M\t Procs\t time_tot\t time_sol')
print(f'{Nx}\t {Ny}\t {M}\t {P}\t {duration1:.6f}\t {duration2:.6f}')

# Если нужно, сохраняем данные в файл:
if args.save:
    filename = 'Example-10-1_Results.npz'
    print(f"Сохраняем данные в файл '{filename}'.")
    # Сохраним данные только для последнего момента времени,
    # чтобы было удобнее сравнивать с параллельными версиями
    # программы, где мы будем собирать на процессе 0 данные
    # только для последнего момента времени:
    np.savez(filename, x=x, y=y, t=T, u=u[-1])

if args.saveall:
    filename = 'Example-10-1_Results_all.npz'
    print(f"Сохраняем данные в файл '{filename}'.")
    # Сохраним данные для всех времён:
    np.savez(filename, x=x, y=y, t=t, u=u)

# Если нужно, рисуем решение для последнего момента времени:
if args.plot:
    from matplotlib import pyplot as plt
    plt.style.use('dark_background')
    fig = plt.figure()
    ax = plt.axes(xlim=(a, b), ylim=(c, d))
    ax.set_xlabel('x'); ax.set_ylabel('y')
    ax.set_aspect('equal')
    X, Y = np.meshgrid(x, y)
    ax.pcolor(X, Y, u[-1, :, :].T, shading='auto')
    ax.text(1.2, -1.7, f't = {t[-1]}')
    plt.show()

#------------------------------------------------------------------
