#------------------------------------------------------------------
# ИЗУЧИТЬ:
# -- Вспоминаем, что такое "неявная" схема метода конечных разностей
#    для решения ДУЧП параболического типа:
#    https://teach-in.ru/lecture/2021-07-19-Lukyanenko
#    http://math.phys.msu.ru/data/785/uravneniya_teploprovodnosti.pdf
#    https://www.rsatu.ru/upload/medialibrary/ac1/Lektsiya-13.pdf
# -- Сравниваем функции `fast_pde_solution()` и `slow_pde_solution()`.
#    Первая функция отличается только использованием "срезов"
#    в массивах библиотеки `numpy` вместо циклов по индексу `n`,
#    что позволяет ускорить вычисления в ~18 раз.
#------------------------------------------------------------------
# Пример 9.1: Последовательное решение одномерного (1D)
#             дифференциального уравнения в частных производных
#             (ДУЧП) параболического типа с использованием
#             "неявной" схемы метода конечных разностей.
#
# Задача: найти решение уравнения:
#            du/dt = eps*(d^2 u/dx^2) + u*(du/dx) + u^3
#         где `eps` - это некоторая константа, а `u(x,t)` - это
#         функция от времени `t` и одной пространственной
#         координаты `x`. Считаем, что эта функция определена
#         на интервале по `x` от `a` до `b` и на интервале
#         по времени от `t0` до `T`.
#
# Для решения такой задачи нам нужно дополнительно знать начальное
# и граничные условия. Будем считать, что в начальный момент времени
# значения этой функции определяются начальным условием:
#    u(x, t0) = u_init(x)
# где функция `u_init(x)` определяется ниже в этом файле.
# Также считаем, что значения функции на границах `x=a` и `x=b`
# определяются граничными условиями:
#    u(a, t) = u_left(t)
#    u(b, t) = u_right(t)
# где функции `u_left(t)` и `u_right(t)` также определяется ниже
# в этом файле.
#
# Для решения уравнения будем использовать метод конечных разностей,
# разбивая диапазон по времени [t0, T] на `M` интервалов и диапазон
# по пространству [a, b] на `N` интервалов.
#
# В этом примере мы будем использовать "неявную" разностную схему
# решения уравнения с весом неявной части `alpha=0.5`, которая
# обладает вторым порядком точности и по времени и по координате:
#    error ~ O(dt^2, dx^2)
# где `dt = (T-t0) / M` - это шаг по времени `t`,
# а `dx = (b-a) / N` - это шаг по координате `x`.
#
# Такая "неявная" схема является гораздо более точной и устойчивой,
# чем "явная" схема, которая рассматривалась в примерах 8.0-8.3.
#
#------------------------------------------------------------------
# Этот пример (в его оригинальном виде "Example-9-1-consecutive.py")
# детально обсуждается в лекции Д.В. Лукьяненко "9. Решение задач
# для уравнений в частных производных. Ч.2":
# https://youtu.be/QuPp0AMiBfU?list=PLcsjsqLLSfNCxGJjuYNZRzeDIFQDQ9WvC
#
# Объяснения математической части разностных методов для решения
# такого уравнения даётся в лекции Д.В. Лукьяненко
# "Лекция 19. Уравнения в частных производных: продолжение":
# https://teach-in.ru/lecture/2021-07-19-Lukyanenko
# Короткое изложение этих методов можно также найти, например, в:
# http://math.phys.msu.ru/data/785/uravneniya_teploprovodnosti.pdf
# https://www.rsatu.ru/upload/medialibrary/ac1/Lektsiya-13.pdf
#------------------------------------------------------------------

import time
import argparse
import numpy as np


#------------------------------------------------------------------
def consecutive_tridiagonal_matrix_algorithm(a, b, c, d):
    """
    Реализация последовательного метода прогонки для решения
    системы линейных уравнений A*x = d с трёхдиагональной
    матрицей `A` размером NxN. Такая матрица определяется тремя
    векторами: вектором `b` (с размером N), задающим главную
    диагональ матрицы, и векторами `a` и `c` (с размером N-1),
    задающими нижнюю и верхнюю кодиагонали, соответственно.

    Для удобства реализации, мы ожидаем, что векторы `a` и `c`
    придут также с размером N, но при этом элементы `a[0]`
    и `c[N-1]` просто не будут использоваться.

    Детали алгоритма метода прогонки описаны на странице:
    https://ru.wikipedia.org/wiki/Метод_прогонки
    Такая реализация метода прогонки требует `8*N-7`
    арифметических операций.

    :param a: Вектор, задающий нижнюю кодиагональ матрицы `A`.
    :param b: Вектор, задающий главную диагональ матрицы `A`.
    :param c: Вектор, задающий верхнюю кодиагональ матрицы `A`.
    :param d: Вектор `d`, задающий правую часть уравнения.
    :return: Вектор решения `x`.
    """
    N = len(d)
    x = np.empty(N, dtype=np.float64)

    # Прямой ход метода прогонки (зануляем нижнюю кодиагональ `a`):
    for n in range(1, N):
        coef = a[n] / b[n-1]
        b[n] -= coef * c[n-1]
        d[n] -= coef * d[n-1]

    # Обратный ход метода прогонки (находим `x`, эффективно зануляя
    # верхнюю кодиагональ `c`):
    x[N-1] = d[N-1] / b[N-1]
    for n in range(N-2, -1, -1):
        x[n] = (d[n] - c[n] * x[n+1])/b[n]

    return x


#------------------------------------------------------------------
def func(u_m):
    global N, eps_dx2, _2dx

    f = np.empty(N-1, dtype=np.float64)
    for n in range(N-1):
        f[n] = eps_dx2*(u_m[n+2] - 2*u_m[n+1] + u_m[n]) + _2dx*u_m[n+1]*(u_m[n+2] - u_m[n]) + u_m[n+1]**3
    return f


#------------------------------------------------------------------
def diagonals_preparation(u_m):
    global N, alpha, eps_dt_dx2, dt_2dx, dt

    a = np.empty(N-1, dtype=np.float64)
    b = np.empty(N-1, dtype=np.float64)
    c = np.empty(N-1, dtype=np.float64)

    for n in range(N-1):
        a[n] = -alpha*(eps_dt_dx2 - dt_2dx*u_m[n+1])
        b[n] = 1.0 - alpha*(- 2*eps_dt_dx2
                            + dt_2dx*(u_m[n+2] - u_m[n])
                            + 3*dt*u_m[n+1]**2)
        c[n] = -alpha*(eps_dt_dx2 + dt_2dx*u_m[n+1])

    return a, b, c


#------------------------------------------------------------------
def u_init(x):
    """
    Функция, определяющая начальное условие для u(x, t):
               u(x, t0) = u_init(x)
    :param x: Значение пространственной координаты `x`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(x, t0)`.
    """
    res = np.sin(3*np.pi*(x - 1/6))
    return res


#------------------------------------------------------------------
def u_left(t):
    """
    Функция, определяющая граничное условие для u(x, t)
    слева, в точке `x=a`:
               u(a, t) = u_left(t)
    :param t: Значение момента времени `t`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(a, t)`.
    """
    res = -1.0
    return res


#------------------------------------------------------------------
def u_right(t):
    """
    Функция, определяющая граничное условие для u(x, t)
    справа, в точке `x=b`:
               u(b, t) = u_right(t)
    :param t: Значение момента времени `t`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(b, t)`.
    """
    res = 1.0
    return res


#------------------------------------------------------------------
def slow_pde_solution():
    """
    Медленная реализация "явной" разностной схемы - основана
    на использовании медленного цикла по отдельным элементам.
    """
    # Используемые глобальные переменные (определяем их здесь
    # вместо передачи в качестве аргументов функции):
    global M, u, t, dt

    # Цикл по всем моментам времени:
    for m in range(M):
        codiag_down, diag, codiag_up = diagonals_preparation(u[m])
        w = consecutive_tridiagonal_matrix_algorithm(
                                            a=codiag_down,
                                            b=diag,
                                            c=codiag_up,
                                            d=func(u[m]))
        u[m + 1, 1:-1] = u[m, 1:-1] + dt * w.real


#------------------------------------------------------------------
def fast_pde_solution():
    """
    Быстрая реализация "явной" разностной схемы - основана
    на использовании "срезов" вместо цикла по отдельным элементам.
    """
    # Пока что одна реализация:
    slow_pde_solution()


#------------------------------------------------------------------
# Начинаем выполнение программы - включаем таймер:
#------------------------------------------------------------------
start_time1 = time.perf_counter()

#------------------------------------------------------------------
# Шаг 0:
# Распарсим аргументы запуска программы.

parser = argparse.ArgumentParser(
            prog='python Example-08-0.py',
            description='Решение 1D ДУЧП параболического типа с использованием '
                        '"явной" разностной схемы без MPI параллелизации.',
)
parser.add_argument('-N', default=800,
                    help='Число `N` интервалов сетки по координате `x`. '
                         'По умолчанию равно 800.')
parser.add_argument('-M', default=1000,
                    help='Число `M` интервалов сетки по времени `t`. '
                         'По умолчанию равно 1000.')
parser.add_argument('-T', default=2.0,
                    help='Максимальное время `T`, до которого должны проводиться '
                         'расчёты. По умолчанию равно 2.0.')
parser.add_argument('--slow', action="store_true",
                    help='Использовать медленную реализацию решения, '
                         'с циклом по `n` при обновлении `u[m,n]` '
                         'вместо использования срезов `u[m,:]`.')
parser.add_argument('--noheader', action="store_true",
                    help='Не печатать названия колонок в выводе времени счёта.')
parser.add_argument('--save', action="store_true",
                    help='Сохранить результаты расчётов в файл '
                         '"Example-08-0_Results.npz".')
parser.add_argument('--plot', action="store_true",
                    help='Нарисовать решение для последнего момента времени.')

args = parser.parse_args()

#------------------------------------------------------------------
# Шаг 1:
# Задаём значения для всех констант, определяемых условиями задачи.
eps = 10**(-1.5)
a = 0.0; b = 1.0
t_0 = 0.0

T = float(args.T)
N = int(args.N)
M = int(args.M)

# Вес неявной части разностной схемы.
# Значение `alpha=0` соответствует явной схеме (рассмотренной в примерах 8.0-8.3),
# а значение `alpha=1` соответствует чисто неявной схеме (также первого порядка
# точности по времени, но безусловно устойчивой при любом шаге по времени).
# Наибольший интерес представляет значение `alpha=0.5`, соответствующее неявной
# схеме второго порядка точности по времени (и по пространству):
alpha = 0.5

#------------------------------------------------------------------
# Шаг 2:
# Находим значения для всех вспомогательных констант.

# Шаг по пространству:
dx = (b - a) / N

# Шаг по времени:
dt = (T - t_0) / M

# Константы для "быстрого" использования внутри разностной схемы:
eps_dt_dx2 = eps * dt / dx ** 2
dt_2dx = dt / (2 * dx)
eps_dx2 = eps / dx ** 2
_2dx = 1.0 / (2 * dx)

# Массивы для хранения точек используемой сетки по пространству:
x = np.linspace(a, b, N+1)
# и по времени:
t = np.linspace(t_0, T, M+1)

#------------------------------------------------------------------
# Шаг 3:
# Задаём начальное и граничные условия.

# Будем хранить все насчитанные данные (для создания анимации):
u = np.empty((M + 1, N + 1))

# Начальное условие:
u[0, :] = u_init(x)

# Граничные условия:
u[:, 0] = u_left(t)
u[:, N] = u_right(t)

# NOTE: Можно более педантично задавать граничные условия как
# u[1:, 0] = u_left(t[1:])
# u[1:, N] = u_right(t[1:])
# Но мы исходим из того, что начальные и граничные условия должны
# быть согласованы, то есть предполагаем, что выполняется условие:
# u_left(t0) == u_init(a) and u_right(t0) == u_init(b)

#------------------------------------------------------------------
# Шаг 4:
# Собственно, и сама нужная нам работа - решение нашего уравнения
# с помощью "явной" разностной схемы. По умолчанию, решаем уравнение
# быстро, но через переключатель '--slow' решаем медленно, как это
# было сделано в оригинальной версии программы. Сравните код обеих
# функций, `slow_pde_solution()` и `fast_pde_solution()`.
# Обратите внимание, что хотя эти функции вызываются без аргументов,
# они переиспользуют многие из введённых выше переменных как глобальные
# переменные (все такие переменные указаны в функциях как `global`).

start_time2 = time.perf_counter()

if args.slow:
    slow_pde_solution()
else:
    fast_pde_solution()

end_time = time.perf_counter()

#------------------------------------------------------------------
# Шаг 5:
# Печатаем время выполнения и, если нужно, сохраняем результаты
# расчётов в файл и/или рисуем график решения.

P = 1  # Число процессов, решающих уравнение.
duration1 = end_time - start_time1
duration2 = end_time - start_time2

if not args.noheader:
    print('N\t M\t Procs\t time_tot\t time_sol')
print(f'{N}\t {M}\t {P}\t {duration1:.6f}\t {duration2:.6f}')

# Если нужно, сохраняем данные в файл:
if args.save:
    filename = 'Example-09-1_Results.npz'
    print(f"Сохраняем данные в файл '{filename}'.")
    np.savez(filename, x=x, t=t, u=u)

# Если нужно, рисуем решение для нескольких моментов времени:
if args.plot:
    from matplotlib import pyplot as plt
    plt.style.use('dark_background')
    fig = plt.figure()
    ax = plt.axes(xlim=(a, b), ylim=(-2.0, 2.0))
    ax.set_xlabel('x'); ax.set_ylabel('u')
    for m in [0, M // 4, M // 2, -1]:
        ax.plot(x, u[m, :], ls='-', lw=2,
                label=f'T = {t[m]}')
    plt.legend()
    plt.show()

#------------------------------------------------------------------
