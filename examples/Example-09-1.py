#------------------------------------------------------------------
# ИЗУЧИТЬ:
# -- Вспоминаем, что такое "неявная" схема метода конечных разностей
#    для решения ДУЧП параболического типа:
#    https://teach-in.ru/lecture/2021-07-19-Lukyanenko
#    http://math.phys.msu.ru/data/785/uravneniya_teploprovodnosti.pdf
#    https://www.rsatu.ru/upload/medialibrary/ac1/Lektsiya-13.pdf
# -- Сравниваем функции `fast_pde_solution()` и `slow_pde_solution()`.
#    Первая функция отличается только использованием библиотечной
#    функции `scipy.linalg.solve_banded()` вместо нашей функции
#    `consecutive_tridiagonal_matrix_algorithm()` для решения
#    трёхдиагональной системы линейных уравнений. Одно это позволяет
#    ускорить вычисления в ~14 раз.
# -- Также для ускорения вычислений, где только возможно,
#    мы по максимуму используем "срезы" в массивах библиотеки
#    `numpy` вместо циклов по индексу `n`.
#------------------------------------------------------------------
# Пример 9.1: Последовательное решение одномерного (1D)
#             дифференциального уравнения в частных производных
#             (ДУЧП) параболического типа с использованием
#             "неявной" схемы метода конечных разностей.
#
# Задача: найти решение уравнения:
#            du/dt = eps*(d^2 u/dx^2) + u*(du/dx) + u^3
#         где `eps` - это некоторая константа, а `u(x,t)` - это
#         функция от времени `t` и одной пространственной
#         координаты `x`. Считаем, что эта функция определена
#         на интервале по `x` от `a` до `b` и на интервале
#         по времени от `t0` до `T`.
#
# Для решения такой задачи нам нужно дополнительно знать начальное
# и граничные условия. Будем считать, что в начальный момент времени
# значения этой функции определяются начальным условием:
#    u(x, t0) = u_init(x)
# где функция `u_init(x)` определяется ниже в этом файле.
# Также считаем, что значения функции на границах `x=a` и `x=b`
# определяются граничными условиями:
#    u(a, t) = u_left(t)
#    u(b, t) = u_right(t)
# где функции `u_left(t)` и `u_right(t)` также определяется ниже
# в этом файле.
#
# Для решения уравнения будем использовать метод конечных разностей,
# разбивая диапазон по времени [t0, T] на `M` интервалов и диапазон
# по пространству [a, b] на `N` интервалов.
#
# В этом примере мы будем использовать "неявную" разностную схему
# решения уравнения с весом неявной части `alpha=0.5`, которая
# обладает вторым порядком точности и по времени и по координате:
#    error ~ O(dt^2, dx^2)
# где `dt = (T-t0) / M` - это шаг по времени `t`,
# а `dx = (b-a) / N` - это шаг по координате `x`.
#
# Такая "неявная" схема является гораздо более точной и устойчивой,
# чем "явная" схема, которая рассматривалась в примерах 8.0-8.3.
# Однако она сложнее в реализации (требует решения трёхдиагональной
# системы линейных уравнений).
#
#------------------------------------------------------------------
# Этот пример (в его оригинальном виде "Example-9-1-consecutive.py")
# детально обсуждается в лекции Д.В. Лукьяненко "9. Решение задач
# для уравнений в частных производных. Ч.2":
# https://youtu.be/QuPp0AMiBfU?list=PLcsjsqLLSfNCxGJjuYNZRzeDIFQDQ9WvC
#
# Объяснения математической части разностных методов для решения
# такого уравнения даётся в лекции Д.В. Лукьяненко
# "Лекция 19. Уравнения в частных производных: продолжение":
# https://teach-in.ru/lecture/2021-07-19-Lukyanenko
# Короткое изложение этих методов можно также найти, например, в:
# http://math.phys.msu.ru/data/785/uravneniya_teploprovodnosti.pdf
# https://www.rsatu.ru/upload/medialibrary/ac1/Lektsiya-13.pdf
#------------------------------------------------------------------

import time
import argparse
import numpy as np
import scipy.linalg


#------------------------------------------------------------------
def consecutive_tridiagonal_matrix_algorithm(a, b, c, d):
    """
    Реализация последовательного метода прогонки для решения
    системы линейных уравнений A*x = d с трёхдиагональной
    матрицей `A` размером NxN. Такая матрица определяется тремя
    векторами: вектором `b` (с размером N), задающим главную
    диагональ матрицы, и векторами `a` и `c` (с размером N-1),
    задающими нижнюю и верхнюю кодиагонали, соответственно.

    Для удобства реализации, мы ожидаем, что векторы `a` и `c`
    придут также с размером N, но при этом элементы `a[0]`
    и `c[N-1]` просто не будут использоваться.

    Детали алгоритма метода прогонки описаны на странице:
    https://ru.wikipedia.org/wiki/Метод_прогонки
    Такая реализация метода прогонки требует `8*N-7`
    арифметических операций.

    :param a: Вектор, задающий нижнюю кодиагональ матрицы `A`.
    :param b: Вектор, задающий главную диагональ матрицы `A`.
    :param c: Вектор, задающий верхнюю кодиагональ матрицы `A`.
    :param d: Вектор `d`, задающий правую часть уравнения.
    :return: Вектор решения `x`.
    """
    N = len(d)
    x = np.empty(N, dtype=np.float64)

    # Прямой ход метода прогонки (зануляем нижнюю кодиагональ `a`):
    for n in range(1, N):
        coef = a[n] / b[n-1]
        b[n] -= coef * c[n-1]
        d[n] -= coef * d[n-1]

    # Обратный ход метода прогонки (находим `x`, эффективно зануляя
    # верхнюю кодиагональ `c`):
    x[N-1] = d[N-1] / b[N-1]
    for n in range(N-2, -1, -1):
        x[n] = (d[n] - c[n] * x[n+1])/b[n]

    return x


#------------------------------------------------------------------
def pde_func(u_m, t):
    """
    Вычисление правой части нашего ДУЧП:
       du/dt = pde_func(u) = eps*(d^2 u/dx^2) + u*(du/dx) + u^3
    для данного вектора решения `u_m = u[m]`.

    :param u_m: Вектор решения `u_m = u[m]`, для которого должна
                быть вычислена правая часть ДУЧП.
    :param t:   Момент времени, для которого должна быть вычислена
                правая часть ДУЧП (подставляется в члены уравнения,
                явно зависящие от времени). В нашем случае этот
                аргумент не используется, но оставлен для полноты.
    :return: Правая часть ДУЧП, вычисленная для промежуточных
             точек по пространству (от `x[1]` до `x[-2]` включительно).
    """
    global eps_dx2, inv_2dx

    f = eps_dx2 * (u_m[2:] - 2*u_m[1:-1] + u_m[:-2]) + \
        inv_2dx * u_m[1:-1] * (u_m[2:] - u_m[:-2]) + \
        u_m[1:-1]**3

    return f


#------------------------------------------------------------------
def pde_jacobian(u_m, t):
    """
    Вычисление матрицы Якоби от правой части нашего ДУЧП:

                                   [ b0 c0  0  0  0]
                                   [ a1 b1 c1  0  0]
    df_du = grad(pde_func(u), u) = [ 0  a2 b2 c2  0]
                                   [ 0  0  a3 b3 c3]
                                   [ 0  0  0  a4 b4]
    где
       pde_func(u) = du/dt = eps*(d^2 u/dx^2) + u*(du/dx) + u^3
    Поскольку после дискретизации по пространству каждый элемент
    `f[n]` правой части нашего ДУЧП зависит только от трёх
    элементов вектора `u_m[n] = u[m][n]`, матрица Якоби
    является трёхдиагональной и состоит из нижней кодиагонали `a`
    (значение `a[n]` получается взятием производной от `f[n]`
    по `u_m[n-1]`, считая, что `a[0]` не определено и его значение
    игнорируется), главной диагонали `b` (значение `b[n]` получается
    взятием производной от `f[n]` по `u_m[n]`), и верхней кодиагонали
    `c` (значение `c[n]` получается взятием производной от `f[n]`
    по `u_m[n+1]`, считая, что `c[-1]` не определено и его значение
    игнорируется).

    :param u_m: Вектор решения `u_m = u[m]`, для которого должна
                быть вычислена матрица Якоби.
    :param t:   Момент времени, для которого должна быть вычислена
                матрица Якоби (подставляется в члены уравнения,
                явно зависящие от времени). В нашем случае этот
                аргумент не используется, но оставлен для полноты.
    :return: Векторы `a`, `b`, и `c`, задающие вышеописанные
             кодиагонали и диагонали матрицы Якоби.
    """
    global eps_dx2, inv_2dx

    a = eps_dx2 - inv_2dx * u_m[1:-1]
    b = - 2*eps_dx2 + inv_2dx * (u_m[2:] - u_m[:-2]) + 3 * u_m[1:-1]**2
    c = eps_dx2 + inv_2dx * u_m[1:-1]

    return a, b, c


#------------------------------------------------------------------
def u_init(x):
    """
    Функция, определяющая начальное условие для u(x, t):
               u(x, t0) = u_init(x)
    :param x: Значение пространственной координаты `x`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(x, t0)`.
    """
    res = np.sin(3*np.pi*(x - 1/6))
    return res


#------------------------------------------------------------------
def u_left(t):
    """
    Функция, определяющая граничное условие для u(x, t)
    слева, в точке `x=a`:
               u(a, t) = u_left(t)
    :param t: Значение момента времени `t`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(a, t)`.
    """
    res = -1.0
    return res


#------------------------------------------------------------------
def u_right(t):
    """
    Функция, определяющая граничное условие для u(x, t)
    справа, в точке `x=b`:
               u(b, t) = u_right(t)
    :param t: Значение момента времени `t`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(b, t)`.
    """
    res = 1.0
    return res


#------------------------------------------------------------------
def slow_pde_solution():
    """
    Медленная реализация "неявной" разностной схемы - основана
    на использовании нашей функции `consecutive_tridiagonal_matrix_algorithm()`
    для решения трёхдиагональной системы линейных уравнений.
    Поскольку эта функция написана на чистом Python и использует
    внутри себя циклы по `n`, она является довольно медленной.
    """
    # Используемые глобальные переменные (определяем их здесь
    # вместо передачи в качестве аргументов функции):
    global M, u, t, alpha, dt

    # Введём промежуточную константу, чтобы избежать двойного
    # умножения векторов на число:
    alpha_dt = alpha*dt

    # Цикл по всем моментам времени:
    for m in range(M):
        # Вычисляем якобиан в момент времени `t[m]` (в начале шага по времени):
        a, b, c = pde_jacobian(u[m], t[m])
        # Вычисляем правую часть ДУЧП в момент времени `t[m] + 0.5*dt`
        # (посредине шага по времени):
        f = pde_func(u[m], t[m] + 0.5*dt)
        # Формируем левую матрицу для вычисления добавки к решению
        # по методу Розенброка и вычисляем эту добавку, решая систему
        # линейных уравнений:
        w = consecutive_tridiagonal_matrix_algorithm(
                                            a=-alpha_dt * a,
                                            b=1.0 - alpha_dt * b,
                                            c=-alpha_dt * c,
                                            d=f)
        # Наконец, находим ожидаемое решение в конце нашего текущего
        # шага по времени:
        u[m + 1, 1:-1] = u[m, 1:-1] + dt * w.real


#------------------------------------------------------------------
def fast_pde_solution():
    """
    Быстрая реализация "неявной" разностной схемы - основана
    на использовании быстрой библиотечной функции
    `scipy.linalg.solve_banded()` для решения трёхдиагональной
    системы линейных уравнений.
    """
    # Используемые глобальные переменные (определяем их здесь
    # вместо передачи в качестве аргументов функции):
    global M, u, t, alpha, dt

    # Введём промежуточную константу, чтобы избежать возможности
    # двойного умножения векторов на число:
    alpha_dt = alpha*dt

    # Цикл по всем моментам времени:
    for m in range(M):
        # Вычисляем якобиан в момент времени `t[m]` (в начале шага по времени):
        a, b, c = pde_jacobian(u[m], t[m])
        # Вычисляем правую часть ДУЧП в момент времени `t[m] + 0.5*dt`
        # (посредине шага по времени):
        f = pde_func(u[m], t[m] + 0.5*dt)
        # Формируем левую матрицу для вычисления добавки к решению
        # по методу Розенброка:
        cba = np.empty((3, len(b)), dtype=np.float64)
        cba[0, 1:] = -alpha_dt * c[:-1]
        cba[1, :] = 1.0 - alpha_dt * b
        cba[2, :-1] = -alpha_dt * a[1:]
        # И вычисляем эту добавку, решая систему линейных уравнений:
        w = scipy.linalg.solve_banded((1, 1), cba, f)

        # Наконец, находим ожидаемое решение в конце нашего текущего
        # шага по времени:
        u[m + 1, 1:-1] = u[m, 1:-1] + dt * w.real


#------------------------------------------------------------------
# Начинаем выполнение программы - включаем таймер:
#------------------------------------------------------------------
start_time1 = time.perf_counter()

#------------------------------------------------------------------
# Шаг 0:
# Распарсим аргументы запуска программы.

parser = argparse.ArgumentParser(
            prog='python Example-09-1.py',
            description='Решение 1D ДУЧП параболического типа с использованием '
                        '"явной" разностной схемы без MPI параллелизации.',
)
parser.add_argument('-N', default=800,
                    help='Число `N` интервалов сетки по координате `x`. '
                         'По умолчанию равно 800.')
parser.add_argument('-M', default=1000,
                    help='Число `M` интервалов сетки по времени `t`. '
                         'По умолчанию равно 1000.')
parser.add_argument('-T', default=2.0,
                    help='Максимальное время `T`, до которого должны проводиться '
                         'расчёты. По умолчанию равно 2.0.')
parser.add_argument('--slow', action="store_true",
                    help='Использовать медленную реализацию решения, '
                         'с вызовом функции `consecutive_tridiagonal_matrix_algorithm()` '
                         'вместо `scipy.linalg.solve_banded()` для решения трёхдиагональной '
                         'системы линейных уравнений.')
parser.add_argument('--noheader', action="store_true",
                    help='Не печатать названия колонок в выводе времени счёта.')
parser.add_argument('--save', action="store_true",
                    help='Сохранить результаты расчётов в файл '
                         '"Example-09-1_Results.npz".')
parser.add_argument('--plot', action="store_true",
                    help='Нарисовать решение для последнего момента времени.')

args = parser.parse_args()

#------------------------------------------------------------------
# Шаг 1:
# Задаём значения для всех констант, определяемых условиями задачи.
eps = 10**(-1.5)
a = 0.0; b = 1.0
t_0 = 0.0

T = float(args.T)
N = int(args.N)
M = int(args.M)

# Вес неявной части разностной схемы.
# Значение `alpha=0` соответствует явной схеме (рассмотренной в примерах 8.0-8.3),
# а значение `alpha=1` соответствует чисто неявной схеме (также первого порядка
# точности по времени, но безусловно устойчивой при любом шаге по времени).
# Наибольший интерес представляет значение `alpha=0.5`, соответствующее неявной
# схеме второго порядка точности по времени (и по пространству):
alpha = 0.5

#------------------------------------------------------------------
# Шаг 2:
# Находим значения для всех вспомогательных констант.

# Шаг по пространству:
dx = (b - a) / N

# Шаг по времени:
dt = (T - t_0) / M

# Константы для "быстрого" использования внутри разностной схемы:
eps_dx2 = eps / dx ** 2
inv_2dx = 1.0 / (2 * dx)

# Массивы для хранения точек используемой сетки по пространству:
x = np.linspace(a, b, N+1)
# и по времени:
t = np.linspace(t_0, T, M+1)

#------------------------------------------------------------------
# Шаг 3:
# Задаём начальное и граничные условия.

# Будем хранить все насчитанные данные (для создания анимации):
u = np.empty((M + 1, N + 1))

# Начальное условие:
u[0, :] = u_init(x)

# Граничные условия:
u[:, 0] = u_left(t)
u[:, N] = u_right(t)

# NOTE: Можно более педантично задавать граничные условия как
# u[1:, 0] = u_left(t[1:])
# u[1:, N] = u_right(t[1:])
# Но мы исходим из того, что начальные и граничные условия должны
# быть согласованы, то есть предполагаем, что выполняется условие:
# u_left(t0) == u_init(a) and u_right(t0) == u_init(b)

#------------------------------------------------------------------
# Шаг 4:
# Собственно, и сама нужная нам работа - решение нашего уравнения
# с помощью "неявной" разностной схемы. По умолчанию, решаем уравнение
# быстро (используя вызов `scipy.linalg.solve_banded()` для решения
# трёхдиагональной системы линейных уравнений), но через переключатель
# '--slow' решаем медленно (используя вызов нашей функции
# `consecutive_tridiagonal_matrix_algorithm()`, как это было сделано
# в оригинальной версии программы). Сравните код обеих функций,
# `slow_pde_solution()` и `fast_pde_solution()`.
# Обратите внимание, что хотя эти функции вызываются без аргументов,
# они переиспользуют многие из введённых выше переменных как глобальные
# переменные (все такие переменные указаны в функциях как `global`).

start_time2 = time.perf_counter()

if args.slow:
    slow_pde_solution()
else:
    fast_pde_solution()

end_time = time.perf_counter()

#------------------------------------------------------------------
# Шаг 5:
# Печатаем время выполнения и, если нужно, сохраняем результаты
# расчётов в файл и/или рисуем график решения.

P = 1  # Число процессов, решающих уравнение.
duration1 = end_time - start_time1
duration2 = end_time - start_time2

if not args.noheader:
    print('N\t M\t Procs\t time_tot\t time_sol')
print(f'{N}\t {M}\t {P}\t {duration1:.6f}\t {duration2:.6f}')

# Если нужно, сохраняем данные в файл:
if args.save:
    filename = 'Example-09-1_Results.npz'
    print(f"Сохраняем данные в файл '{filename}'.")
    np.savez(filename, x=x, t=t, u=u)

# Если нужно, рисуем решение для нескольких моментов времени:
if args.plot:
    from matplotlib import pyplot as plt
    plt.style.use('dark_background')
    fig = plt.figure()
    ax = plt.axes(xlim=(a, b), ylim=(-2.0, 2.0))
    ax.set_xlabel('x'); ax.set_ylabel('u')
    for m in [0, M // 4, M // 2, -1]:
        ax.plot(x, u[m, :], ls='-', lw=2,
                label=f'T = {t[m]}')
    plt.legend()
    plt.show()

#------------------------------------------------------------------
