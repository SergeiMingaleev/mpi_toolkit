#------------------------------------------------------------------
# Пример 20.1: Последовательное решение двумерного (2D)
#              дифференциального уравнения в частных производных
#              (ДУЧП) гиперболического типа (а именно, волнового
#              уравнения со вторыми производными по времени
#              и пространству) с использованием "явной" схемы
#              метода конечных разностей.
#
# Задача: найти решение уравнения:
#            d^2 u/dt^2 = c^2*(d^2 u/dx^2 + d^2 u/dy^2)
#         где `c` - это скорость распространения волны,
#         а `u(x,t)` - это функция от времени `t` и двух
#         пространственных координат, `x` и `y`. Считаем,
#         что эта функция определена на интервале по `x`
#         от `xmin` до `xmax`, на интервале по `y` от `ymin`
#         до `ymax` и на интервале по времени от `t0` до `T`.
#
# Для решения такой задачи нам нужно дополнительно знать начальное
# и граничные условия. Будем считать, что в начальный момент времени
# значения этой функции и её первой производной по времени определяются
# начальными условиями:
#    u(x, y, t0) = u_init(x, y)
#    d u(x, y, t0)/dt = dudt_init(x, y)
# где функции `u_init(x, y)` и `dudt_init(x, y)` определяются
# ниже в этом файле.
# Также считаем, что значения функции на границах `x=xmin` и `x=xmax`
# и границах `y=ymin` и `y=ymax` определяются граничными условиями:
#    u(xmin, y, t) = u_left(y, t)
#    u(xmax, y, t) = u_right(y, t)
#    u(x, ymin, t) = u_bottom(x, t)
#    u(x, ymax, t) = u_top(x, t)
# где функции `u_left(y, t)`, `u_right(y, t)`, `u_bottom(x, t)`,
# и `u_top(x, t)` также определяются ниже в этом файле.
#
# Для решения уравнения будем использовать метод конечных разностей,
# разбивая диапазон [t0, T] по времени на `M` интервалов, диапазон
# [xmin, xmax] по оси `x` на `Nx` интервалов, и диапазон [ymin, ymax]
# по оси `y` на `Ny` интервалов.
#
# Для простоты реализации, в этом примере мы будем использовать
# "явную" разностную схему решения уравнения, которая обладает
# вторым порядком точности и по времени и по пространственным
# координатам:
#    error ~ O(dt^2, dx^2, dy^2)
# где `dt = (T-t0) / M` - это шаг по времени `t`,
# `dx = (xmax-xmin) / Nx` - это шаг по координате `x`,
# `dy = (ymax-ymin) / Ny` - это шаг по координате `y`.
#
# Такая "явная" схема является условно устойчивой при выполнении
# условия Куранта-Фридрихса-Леви (КФЛ) на максимальный шаг по времени:
#    dt * c * sqrt(1/dx^2 + 1/dy^2) <= 1.0
#
#------------------------------------------------------------------

import time
import argparse
import numpy as np

try:
    # Добавим цветной вывод для WARNING:
    import colorama
    colorama.init(autoreset=True)
except ModuleNotFoundError:
    colorama = None


#------------------------------------------------------------------
def unit_array(vec1, vec2):
    if np.isscalar(vec1) and np.isscalar(vec2):
        return 1.0
    if np.isscalar(vec1):
        vec1 = np.array([vec1])
    if np.isscalar(vec2):
        vec2 = np.array([vec2])
    res = np.ones((len(vec1), len(vec2)))
    return res


#------------------------------------------------------------------
def u_exact(t, x, y):
    """
    Функция, определяющая точное решение u(x, y, t)
    для любых значений t, x, и y.
    :param t: Число, задающее значение нужного момента
              времени `t`.
    :param x: Значение пространственной координаты `x`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :param y: Значение пространственной координаты `y`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение точного решения `u(t, x, y)`.
    """
    global omega, kx, ky
    if not np.isscalar(x) and not np.isscalar(y):
        x, y = np.meshgrid(x, y)
        x = x.T
        y = y.T
    res = np.sin(kx * x) * np.sin(ky * y) * np.sin(omega * t)
    return res


#------------------------------------------------------------------
def u_init(x, y):
    """
    Функция, определяющая начальное условие для u(x, y, t):
               u(x, y, t0) = u_init(x, y)
    :param x: Значение пространственной координаты `x`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :param y: Значение пространственной координаты `y`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(x, y, t0)`.
    """
    if not np.isscalar(x) and not np.isscalar(y):
        x, y = np.meshgrid(x, y)
        x = x.T
        y = y.T
    # Нулевое начальное условие:
    res = 0.0 * x * y
    return res


#------------------------------------------------------------------
def dudt_init(x, y):
    """
    Функция, определяющая начальное условие для первой производной
    от u(x, y, t) по времени:
               d u(x, y, t0) / dt = dudt_init(x, y)
    :param x: Значение пространственной координаты `x`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :param y: Значение пространственной координаты `y`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(x, y, t0)`.
    """
    global omega, kx, ky
    if not np.isscalar(x) and not np.isscalar(y):
        x, y = np.meshgrid(x, y)
        x = x.T
        y = y.T
    res = omega * np.sin(kx * x) * np.sin(ky * y)
    return res


#------------------------------------------------------------------
def u_left(y, t):
    """
    Функция, определяющая граничное условие для u(x, y, t)
    слева, в точке `x=a`:
               u(a, y, t) = u_left(y, t)
    :param y: Значение пространственной координаты `y`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :param t: Значение момента времени `t`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(a, y, t)`.
    """
    res = 0.0 * unit_array(t, y)
    return res


#------------------------------------------------------------------
def u_right(y, t):
    """
    Функция, определяющая граничное условие для u(x, y, t)
    справа, в точке `x=b`:
               u(b, y, t) = u_right(y, t)
    :param y: Значение пространственной координаты `y`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :param t: Значение момента времени `t`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(b, y, t)`.
    """
    res = 0.0 * unit_array(t, y)
    return res


#------------------------------------------------------------------
def u_top(x, t):
    """
    Функция, определяющая граничное условие для u(x, y, t)
    сверху, в точке `y=d`:
               u(x, d, t) = u_top(x, t)
    :param x: Значение пространственной координаты `x`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :param t: Значение момента времени `t`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(x, d, t)`.
    """
    res = 0.0 * unit_array(t, x)
    return res


#------------------------------------------------------------------
def u_bottom(x, t):
    """
    Функция, определяющая граничное условие для u(x, y, t)
    снизу, в точке `y=c`:
               u(x, c, t) = u_bottom(x, t)
    :param x: Значение пространственной координаты `x`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :param t: Значение момента времени `t`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(x, c, t)`.
    """
    res = 0.0 * unit_array(t, x)
    return res


#------------------------------------------------------------------
def slow_pde_solution():
    """
    Медленная реализация "явной" разностной схемы - основана
    на использовании медленного цикла по отдельным элементам.
    """
    # Используемые глобальные переменные (определяем их здесь
    # вместо передачи в качестве аргументов функции):
    global M, Nx, Ny, u, c_dt_dx2, c_dt_dy2, dt

    # Цикл по всем моментам времени:
    for m in range(1, M):
        # Первые и последние элементы не обновляются -
        # они определяются граничными условиями:
        for i in range(1, Nx):
            for j in range(1, Ny):
                u[m+1, i, j] = 2 * u[m, i, j] - u[m-1, i, j] + \
                               c_dt_dx2 * (u[m, i+1, j] - 2*u[m, i, j] + u[m, i-1, j]) + \
                               c_dt_dy2 * (u[m, i, j+1] - 2*u[m, i, j] + u[m, i, j-1])


#------------------------------------------------------------------
def fast_pde_solution():
    """
    Быстрая реализация "явной" разностной схемы - основана
    на использовании "срезов" вместо цикла по отдельным элементам.
    """
    # Используемые глобальные переменные (определяем их здесь
    # вместо передачи в качестве аргументов функции):
    global M, Nx, Ny, u, c_dt_dx2, c_dt_dy2, dt

    # Цикл по всем моментам времени:
    for m in range(1, M):
        # Первые и последние элементы не обновляются -
        # они определяются граничными условиями:
        u[m+1, 1:-1, 1:-1] = 2 * u[m, 1:-1, 1:-1] - u[m-1, 1:-1, 1:-1] + \
                       c_dt_dx2 * (u[m, 2:, 1:-1] - 2*u[m, 1:-1, 1:-1] + u[m, :-2, 1:-1]) + \
                       c_dt_dy2 * (u[m, 1:-1, 2:] - 2*u[m, 1:-1, 1:-1] + u[m, 1:-1, :-2])


#------------------------------------------------------------------
# Начинаем выполнение программы - включаем таймер:
#------------------------------------------------------------------
start_time1 = time.perf_counter()

#------------------------------------------------------------------
# Шаг 0:
# Распарсим аргументы запуска программы.

parser = argparse.ArgumentParser(
            prog='python Example-20-1.py',
            description='Решение 2D ДУЧП гиперболического типа с использованием '
                        '"явной" разностной схемы без MPI параллелизации.',
)
parser.add_argument('-Nx', default=100,
                    help='Число `Nx` интервалов сетки по координате `x`. '
                         'По умолчанию равно 100.')
parser.add_argument('-Ny', default=100,
                    help='Число `Ny` интервалов сетки по координате `y`. '
                         'По умолчанию равно 100.')
parser.add_argument('-M', default=1000,
                    help='Число `M` интервалов сетки по времени `t`. '
                         'По умолчанию равно 1000.')
parser.add_argument('-T', default=5.0,
                    help='Максимальное время `T`, до которого должны проводиться '
                         'расчёты. По умолчанию равно 5.0.')
parser.add_argument('--slow', action="store_true",
                    help='Использовать медленную реализацию решения, '
                         'с циклом по `i` и `j` при обновлении `u[m,i,j]` '
                         'вместо использования срезов `u[m,:,:]`.')
parser.add_argument('--noheader', action="store_true",
                    help='Не печатать названия колонок в выводе времени счёта.')
parser.add_argument('--save', action="store_true",
                    help='Сохранить результаты расчётов для последнего момента '
                         'времени в файл "Example-20-1_Results.npz".')
parser.add_argument('--saveall', action="store_true",
                    help='Сохранить результаты расчётов для всех моментов '
                         'времени в файл "Example-20-1_Results_all.npz".')
parser.add_argument('--plot', action="store_true",
                    help='Нарисовать решение для последнего момента времени.')

args = parser.parse_args()

#------------------------------------------------------------------
# Шаг 1:
# Задаём значения для всех констант, определяемых условиями задачи.
c = 1.0
xmin = ymin = 0.0
xmax = ymax = 1.0
t_0 = 0.0

T = float(args.T)
Nx = int(args.Nx)
Ny = int(args.Ny)
M = int(args.M)

#------------------------------------------------------------------
# Шаг 2:
# Находим значения для всех вспомогательных констант.

# Шаг по пространству:
dx = (xmax - xmin) / Nx
dy = (ymax - ymin) / Ny

# Шаг по времени:
dt = (T - t_0) / M

# Константы для "быстрого" использования внутри разностной схемы:
c_dt_dx2 = (c * dt / dx)**2
c_dt_dy2 = (c * dt / dy)**2

# Условие устойчивости "явной" разностной схемы
#    dt * c * sqrt(1/dx^2 + 1/dy^2) <= 1.0
# соответсвтует условию
#   c_dt_dx2 + c_dt_dy2 <= 1.0
# Проверим его:
msg = None
stability_factor = c_dt_dx2 + c_dt_dy2
if stability_factor > 1.0:
    msg = f'WARNING: Нарушено условие устойчивости "явной" разностной схемы: ' + \
          f'c*dt*sqrt(1/dx^2 + 1/dy^2) = {stability_factor:.3f} (а должно быть меньше 1!).'
    # Выведем это предупреждение ярко-красным:
    msg = msg if colorama is None else colorama.Fore.LIGHTRED_EX + msg
    print(msg)

# Массивы для хранения точек используемой сетки по пространству:
x = np.linspace(xmin, xmax, Nx+1)
y = np.linspace(ymin, ymax, Ny+1)
# и по времени:
t = np.linspace(t_0, T, M+1)

#------------------------------------------------------------------
# Шаг 3:
# Задаём начальное и граничные условия.

kx = 2 * np.pi / xmax
ky = 3 * np.pi / ymax
omega = c * np.sqrt(kx**2 + ky**2)

# Будем хранить все насчитанные данные (для создания анимации):
u = np.empty((M + 1, Nx + 1, Ny + 1))

# Начальное условие на значение самой функции:
u[0, :, :] = u_init(x, y)

# Начальное условие на значение первой производной функции
# по времени позволяет задать значение функции на второй итерации.
# Чтобы это условие выполнялось со вторым порядком точности,
# мы вводим в него поправки:

u[1, 1:-1, 1:-1] = u[0, 1:-1, 1:-1] + dt * dudt_init(x[1:-1], y[1:-1]) + \
           0.5 * c_dt_dx2 * (u[0, 2:, 1:-1] - 2 * u[0, 1:-1, 1:-1] + u[0, :-2, 1:-1]) + \
           0.5 * c_dt_dy2 * (u[0, 1:-1, 2:] - 2 * u[0, 1:-1, 1:-1] + u[0, 1:-1, :-2])

# Граничные условия:
u[:, 0, :] = u_left(y, t)
u[:, Nx, :] = u_right(y, t)
u[:, :, 0] = u_bottom(x, t)
u[:, :, Ny] = u_top(x, t)

#------------------------------------------------------------------
# Шаг 4:
# Собственно, и сама нужная нам работа - решение нашего уравнения
# с помощью "явной" разностной схемы. По умолчанию, решаем уравнение
# быстро, но через переключатель '--slow' решаем медленно, как это
# было сделано в оригинальной версии программы. Сравните код обеих
# функций, `slow_pde_solution()` и `fast_pde_solution()`.
# Обратите внимание, что хотя эти функции вызываются без аргументов,
# они переиспользуют многие из введённых выше переменных как глобальные
# переменные (все такие переменные указаны в функциях как `global`).

start_time2 = time.perf_counter()

if args.slow:
    slow_pde_solution()
else:
    fast_pde_solution()

end_time = time.perf_counter()

#------------------------------------------------------------------
# Шаг 5:
# Печатаем время выполнения и, если нужно, сохраняем результаты
# расчётов в файл и/или рисуем график решения.

# Мы знаем точное решение - посчитаем ошибку расчётов:
error = np.max(np.abs(u[-1] - u_exact(t[-1], x, y)))

P = Px = Py = 1  # Число процессов, решающих уравнение.
B = 0  # Число слоёв на каждой границе, передаваемых соседнему процессу.
duration1 = end_time - start_time1
duration2 = end_time - start_time2

if not args.noheader:
    print('Nx\t Ny\t M\t Procs\t Px\t Py\t B\t time_tot\t time_sol \t error')
print(f'{Nx}\t {Ny}\t {M}\t {P}\t {Px}\t {Py}\t {B}\t {duration1:.6f}\t {duration2:.6f}\t {error:.6f}')

# Если нужно, сохраняем данные в файл:
if args.save:
    filename = 'Example-20-1_Results.npz'
    print(f"Сохраняем данные в файл '{filename}'.")
    # Сохраним данные только для последнего момента времени,
    # чтобы было удобнее сравнивать с параллельными версиями
    # программы, где мы будем собирать на процессе 0 данные
    # только для последнего момента времени:
    np.savez(filename, x=x, y=y, t=T, u=u[-1])

if args.saveall:
    filename = 'Example-20-1_Results_all.npz'
    print(f"Сохраняем данные в файл '{filename}'.")
    # Сохраним данные для всех времён:
    np.savez(filename, x=x, y=y, t=t, u=u)

# Если нужно, рисуем решение для последнего момента времени:
if args.plot:
    from matplotlib import pyplot as plt
    plt.style.use('dark_background')
    fig = plt.figure()
    ax = plt.axes(xlim=(xmin, xmax), ylim=(ymin, ymax))
    ax.set_xlabel('x'); ax.set_ylabel('y')
    ax.set_aspect('equal')
    X, Y = np.meshgrid(x, y)
    ax.pcolor(X, Y, u[-1, :, :].T, shading='auto')
    ax.text(1.2, -1.7, f't = {t[-1]}')
    plt.show()

#------------------------------------------------------------------
