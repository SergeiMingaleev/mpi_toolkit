#------------------------------------------------------------------
# ИЗУЧИТЬ:
# -- Вспоминаем, что такое дифференциальные уравнения в частных
#    производных (ДУЧП) параболического типа.
# -- Вспоминаем, что такое "явная" схема метода конечных разностей
#    для решения ДУЧП параболического типа:
#    https://teach-in.ru/lecture/2021-07-19-Lukyanenko
#    https://www.rsatu.ru/upload/medialibrary/ac1/Lektsiya-13.pdf
# -- Сравниваем функции `fast_pde_solution()` и `slow_pde_solution()`
#    и вспоминаем/изучаем использование "срезов" в массивах
#    библиотеки `numpy`:
#    https://copython.ru/narezka-massiva-numpy-v-python-na-primerah
#    https://youtu.be/Bhmu9ftCGkk
# -- По желанию: смотрим, как пользоваться классом
#    `argparse.ArgumentParser()` (это может пригодиться для
#    добавления удобной обработки аргументов в ваших программах):
#    https://docs.python.org/3/howto/argparse.html
#    https://habr.com/ru/companies/ruvds/articles/440654/
#    https://pyneng.readthedocs.io/ru/latest/book/additional_info/argparse.html
#------------------------------------------------------------------
# Пример 8.0: Последовательное решение одномерного (1D)
#             дифференциального уравнения в частных производных
#             параболического типа с использованием "явной" схемы
#             метода конечных разностей.
#
# Задача: найти решение уравнения:
#            du/dt = eps*(d^2 u/dx^2) + u*(du/dx) + u^3
#         где `eps` - это некоторая константа, а `u(x,t)` - это
#         функция от времени `t` и одной пространственной
#         координаты `x`. Считаем, что эта функция определена
#         на интервале по `x` от `a` до `b` и на интервале
#         по времени от `t0` до `T`.
#
# Для решения такой задачи нам нужно дополнительно знать начальное
# и граничные условия. Будем считать, что в начальный момент времени
# значения этой функции определяются начальным условием:
#    u(x, t0) = u_init(x)
# где функция `u_init(x)` определяется ниже в этом файле.
# Также считаем, что значения функции на границах `x=a` и `x=b`
# определяются граничными условиями:
#    u(a, t) = u_left(t)
#    u(b, t) = u_right(t)
# где функции `u_left(t)` и `u_right(t)` также определяется ниже
# в этом файле.
#
# Для решения уравнения будем использовать метод конечных разностей,
# разбивая диапазон по времени [t0, T] на `M` интервалов и диапазон
# по пространсту [a, b] на `N` интервалов.
#
# Для простоты реализации, в этом примере мы будем использовать
# "явную" разностную схему решения уравнения, которая обладает
# первым порядком точности по времени и вторым порядком точности
# по координате:
#    error ~ O(dt, dx^2)
# где `dt = (T-t0) / M` - это шаг по времени `t`,
# а `dx = (b-a) / N` - это шаг по координате `x`.
#
# Такая "явная" схема является условно устойчивой только при выполнении
# жёсткого условия на максимальный шаг по времени:
#    dt < dx^2 / (2*eps)
# что приводит к требованию, что число интервалов по времени `M` должно
# расти как квадрат числа интервалов по пространству `N`: M ~ N^2.
# То есть, при увеличении `N` в 10 раз, нужно увеличить `M` в сто раз!
#
# Более эффективная "неявная" схема решения этого же уравнения будет
# рассмотрена в примерах 9.1 и 9.2 (но она потребует более сложной
# программной реализации, основанной на решении трёхдиагональной
# системы линейных уравнений).
#
#------------------------------------------------------------------
# Этот пример (в его оригинальном виде "Example-8-1-consecutive.py")
# детально обсуждается в лекции Д.В. Лукьяненко "8. Решение задач
# для уравнений в частных производных. Ч.1":
# https://youtu.be/6SYN28B_iyE?list=PLcsjsqLLSfNCxGJjuYNZRzeDIFQDQ9WvC
#
# Объяснения математической части разностных методов для решения
# такого уравнения даётся в лекции Д.В. Лукьяненко
# "Лекция 19. Уравнения в частных производных: продолжение":
# https://teach-in.ru/lecture/2021-07-19-Lukyanenko
# Короткое изложение этих методов можно также найти, например, в:
# https://www.rsatu.ru/upload/medialibrary/ac1/Lektsiya-13.pdf
#------------------------------------------------------------------

import time
import argparse
import numpy as np

try:
    # Добавим цветной вывод для WARNING:
    import colorama
    colorama.init(autoreset=True)
except ModuleNotFoundError:
    colorama = None


#------------------------------------------------------------------
def u_init(x):
    """
    Функция, определяющая начальное условие для u(x, t):
               u(x, t0) = u_init(x)
    :param x: Значение пространственной координаты `x`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(x, t0)`.
    """
    res = np.sin(3*np.pi*(x - 1/6))
    return res


#------------------------------------------------------------------
def u_left(t):
    """
    Функция, определяющая граничное условие для u(x, t)
    слева, в точке `x=a`:
               u(a, t) = u_left(t)
    :param t: Значение момента времени `t`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(a, t)`.
    """
    res = -1.0
    return res


#------------------------------------------------------------------
def u_right(t):
    """
    Функция, определяющая граничное условие для u(x, t)
    справа, в точке `x=b`:
               u(b, t) = u_left(t)
    :param t: Значение момента времени `t`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(b, t)`.
    """
    res = 1.0
    return res


#------------------------------------------------------------------
def slow_pde_solution():
    """
    Медленная реализация "явной" разностной схемы - основана
    на использовании медленного цикла по отдельным элементам.
    """
    global M, N, u, eps_dt_dx2, dt_2dx, dt

    # Первый и последний элементы не обновляются -
    # они определяются граничными условиями:
    for m in range(M):
        for n in range(1, N):
            u[m+1, n] = u[m, n] + \
                        eps_dt_dx2 * (u[m, n+1] - 2*u[m, n] + u[m, n-1]) + \
                        dt_2dx * u[m, n] * (u[m, n+1] - u[m, n-1]) + \
                        dt * u[m, n]**3


#------------------------------------------------------------------
def fast_pde_solution():
    """
    Быстрая реализация "явной" разностной схемы - основана
    на использовании "срезов" вместо цикла по отдельным элементам.
    """
    global M, u, eps_dt_dx2, dt_2dx, dt

    # Первый и последний элементы не обновляются -
    # они определяются граничными условиями:
    for m in range(M):
        u[m+1, 1:-1] = u[m, 1:-1] + \
                       eps_dt_dx2 * (u[m, 2:] - 2*u[m, 1:-1] + u[m, :-2]) + \
                       dt_2dx * u[m, 1:-1] * (u[m, 2:] - u[m, :-2]) + \
                       dt * u[m, 1:-1]**3


#------------------------------------------------------------------
# Начинаем выполнение программы - включаем таймер:
#------------------------------------------------------------------
start_time1 = time.perf_counter()

#------------------------------------------------------------------
# Шаг 0:
# Распарсим аргументы запуска программы.

parser = argparse.ArgumentParser(
            prog='python Example-08-0.py',
            description='Решение 1D ДУЧП параболического типа с использованием '
                        '"явной" разностной схемы без MPI параллелизации.',
)
parser.add_argument('-N', default=800,
                    help='Число `N` интервалов сетки по координате `x`. '
                         'По умолчанию равно 800.')
parser.add_argument('-M', default=100_000,
                    help='Число `M` интервалов сетки по времени `t`. '
                         'По умолчанию равно 100_000.')
parser.add_argument('-T', default=2.0,
                    help='Максимальное время `T`, до которого должны проводиться '
                         'расчёты. По умолчанию равно 2.0.')
parser.add_argument('--slow', action="store_true",
                    help='Использовать медленную реализацию решения, '
                         'с циклом по `n` при обновлении `u[m,n]` '
                         'вместо использования срезов `u[m,:]`.')
parser.add_argument('--noheader', action="store_true",
                    help='Не печатать названия колонок в выводе времени счёта.')
parser.add_argument('--save', action="store_true",
                    help='Сохранить результаты расчётов в файл '
                         '"Example-08-0_Results.npz".')
parser.add_argument('--plot', action="store_true",
                    help='Нарисовать решение для последнего момента времени.')

args = parser.parse_args()

#------------------------------------------------------------------
# Шаг 1:
# Задаём значения для всех констант, определяемых условиями задачи.
eps = 10**(-1.5)
a = 0.0; b = 1.0
t_0 = 0.0

T = float(args.T)
N = int(args.N)
M = int(args.M)

#------------------------------------------------------------------
# Шаг 2:
# Находим значения для всех вспомогательных констант.

# Шаг по пространству:
dx = (b - a) / N

# Шаг по времени:
dt = (T - t_0) / M

# Константы для "быстрого" использования внутри разностной схемы:
eps_dt_dx2 = eps * dt / dx ** 2
dt_2dx = dt / (2 * dx)

# Условие устойчивости "явной" разностной схемы `dt < dx^2 / (2*eps)`
# соответсвтует условию `eps_dt_dx2 < 0.5` - проверим его:
if eps_dt_dx2 >= 0.5:
    msg = f'WARNING: Нарушено условие устойчивости "явной" разностной схемы: ' + \
          f'eps_dt_dx2 = {eps_dt_dx2:.3f} (а должно быть меньше 0.5!).'
    # Выведем это предупреждение ярко-красным:
    msg = msg if colorama is None else colorama.Fore.LIGHTRED_EX + msg
    print(msg)

# Массивы для хранения точек используемой сетки по пространству:
x = np.linspace(a, b, N+1)
# и по времени:
t = np.linspace(t_0, T, M+1)

#------------------------------------------------------------------
# Шаг 3:
# Задаём начальное и граничные условия.

# Будем хранить все насчитанные данные (для создания анимации):
u = np.empty((M + 1, N + 1))

# Начальное условие:
u[0, :] = u_init(x)

# Граничные условия:
u[:, 0] = u_left(t)
u[:, N] = u_right(t)

# NOTE: Можно более педантично задавать граничные условия как
# u[1:, 0] = u_left(t[1:])
# u[1:, N] = u_right(t[1:])
# Но мы исходим из того, что начальные и граничные условия должны
# быть согласованы, то есть предполагаем, что выполняется условие:
# u_left(t0) == u_init(a) and u_right(t0) == u_init(b)

#------------------------------------------------------------------
# Шаг 4:
# Собственно, и сама нужная нам работа - решение нашего уравнения
# с помощью "явной" разностной схемы. По умолчанию, решаем уравнение
# быстро, но через переключатель '--slow' решаем медленно, как это
# было сделано в оригинальной версии программы. Сравните код обеих
# функций, `slow_pde_solution()` и `fast_pde_solution()`.

start_time2 = time.perf_counter()

if args.slow:
    slow_pde_solution()
else:
    fast_pde_solution()

end_time = time.perf_counter()

#------------------------------------------------------------------
# Шаг 5:
# Печатаем время выполнения и, если нужно, сохраняем результаты
# расчётов в файл и/или рисуем график решения.

P = 1  # Число процессов, решающих уравнение.
duration1 = end_time - start_time1
duration2 = end_time - start_time2

if not args.noheader:
    print('N\t M\t Procs\t time_tot\t time_sol')
print(f'{N}\t {M}\t {P}\t {duration1:.6f}\t {duration2:.6f}')

# Если нужно, сохраняем данные в файл:
if args.save:
    filename = 'Example-08-0_Results.npz'
    print(f"Сохраняем данные в файл '{filename}'.")
    np.savez(filename, x=x, t=t, u=u)

# Если нужно, рисуем решение для последнего момента времени:
if args.plot:
    from matplotlib import pyplot as plt
    plt.style.use('dark_background')
    fig = plt.figure()
    ax = plt.axes(xlim=(a,b), ylim=(-2.0, 2.0))
    ax.set_xlabel('x'); ax.set_ylabel('u')
    for m in [0, M//4, M//2, -1]:
        ax.plot(x, u[m, :], ls='-', lw=2,
                label=f'T = {t[m]}')
    plt.legend()
    plt.show()

#------------------------------------------------------------------
