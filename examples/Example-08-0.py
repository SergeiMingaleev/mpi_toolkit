#------------------------------------------------------------------
# ИЗУЧИТЬ:
# -- Вспоминаем, что такое дифференциальные уравнения в частных
#    производных (ДУЧП) параболического типа.
# -- Вспоминаем, что такое "явная" схема метода конечных разностей
#    для решения ДУЧП параболического типа:
#    https://teach-in.ru/lecture/2021-07-19-Lukyanenko
#    https://www.rsatu.ru/upload/medialibrary/ac1/Lektsiya-13.pdf
# -- Сравниваем функции `fast_pde_solution()` и `slow_pde_solution()`
#    и вспоминаем/изучаем использование "срезов" в массивах
#    библиотеки `numpy`:
#    https://copython.ru/narezka-massiva-numpy-v-python-na-primerah
#    https://youtu.be/Bhmu9ftCGkk
# -- По желанию: смотрим, как пользоваться классом
#    `argparse.ArgumentParser` (может пригодиться для добавления
#    удобной обработки аргументов в ваших программах):
#    https://docs.python.org/3/howto/argparse.html
#    https://habr.com/ru/companies/ruvds/articles/440654/
#    https://pyneng.readthedocs.io/ru/latest/book/additional_info/argparse.html
#------------------------------------------------------------------
# Пример 8.0: Последовательное решение одномерного (1D)
#             дифференциального уравнения в частных производных
#             параболического типа с использованием явной схемы
#             метода конечных разностей.
#
# Задача: найти решение уравнения:
#            du/dt = eps*(d^2 u/dx^2) + u*(du/dx) + u^3
#         где `eps` - это некоторая константа, а `u(x,t)` - это
#         функция от времени `t` и одной пространственной
#         координаты `x`. Считаем, что эта функция определена
#         на интервале по `x` от `a` до `b` и на интервале
#         по времени от `t0` до `T`.
#
# Для решения такой задачи нам нужно дополнительно знать начальное
# и граничные условия. Будем считать, что в начальный момент времени
# значения этой функции определяются начальным условием:
#    u(x, t0) = u_init(x)
# где функция `u_init(x)` определяется ниже в этом файле.
# Также считаем, что значения функции на границах `x=a` и `x=b`
# определяются граничными условиями:
#    u(a, t) = u_left(t)
#    u(b, t) = u_right(t)
# где функции `u_left(t)` и `u_right(t)` также определяется ниже
# в этом файле.
#
# Для решения уравнения будем использовать метод конечных разностей,
# разбивая диапазон по времени [t0, T] на `M` интервалов и диапазон
# по пространсту [a, b] на `N` интервалов.
#
# Для простоты реализации, в этом примере мы будем использовать
# "явную" разностную схему решения уравнения, которая обладает
# первым порядком точности по времени и вторым порядком точности
# по координате:
#    error ~ O(dt, dx^2)
# где `dt = (T-t0) / M` - это шаг по времени `t`,
# а `dx = (b-a) / N` - это шаг по координате `x`.
#
# Такая "явная" схема является условно устойчивой только при выполнении
# жёсткого условия на максимальный шаг по времени:
#    dt < dx^2 / (2*eps)
# что приводит к требованию, что число интервалов по времени `M` должно
# расти как квадрат числа интервалов по пространству `N`: M ~ N^2.
# То есть, при увеличении `N` в 10 раз, нужно увеличить `M` в сто раз!
#
# Более эффективная "неявная" схема решения этого же уравнения будет
# рассмотрена в примерах 9.1 и 9.2 (но она потребует более сложной
# программной реализации).
#
#------------------------------------------------------------------
# Этот пример (в его оригинальном виде) детально обсуждается
# в лекции Д.В. Лукьяненко "8. Решение задач для уравнений
# в частных производных.Ч.1":
# https://youtu.be/6SYN28B_iyE?list=PLcsjsqLLSfNCxGJjuYNZRzeDIFQDQ9WvC
#
# Объяснения математической части разностных методов для рашения такого
# уравнения даются в лекциях Д.В. Лукьяненко:
# Лекция 19. Уравнения в частных производных: продолжение:
# https://teach-in.ru/lecture/2021-07-19-Lukyanenko
# Короткое изложение этих методов можно также найти, например, в:
# https://www.rsatu.ru/upload/medialibrary/ac1/Lektsiya-13.pdf
#------------------------------------------------------------------

import time
import argparse
import numpy as np


#------------------------------------------------------------------
def u_init(x):
    """
    Функция, определяющая начальное условие для u(x, t):
               u(x, t0) = u_init(x)
    :param x: Значение пространственной координаты `x`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(x, t0)`.
    """
    u_init = np.sin(3*np.pi*(x - 1/6))
    return u_init


#------------------------------------------------------------------
def u_left(t):
    """
    Функция, определяющая граничное условие для u(x, t)
    слева, в точке `x=a`:
               u(a, t) = u_left(t)
    :param t: Значение момента времени `t`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(a, t)`.
    """
    u_left = -1.0
    return u_left


#------------------------------------------------------------------
def u_right(t):
    """
    Функция, определяющая граничное условие для u(x, t)
    справа, в точке `x=b`:
               u(b, t) = u_left(t)
    :param t: Значение момента времени `t`.
              Может быть либо одним числом, либо `numpy`
              массивом, задающим все нужные точки.
    :return: Значение функции для задания `u(b, t)`.
    """
    u_right = 1.0
    return u_right


#------------------------------------------------------------------
def slow_pde_solution():
    """
    Медленная реализация "явной" разностной схемы - основана
    на использовании медленного цикла по отдельным элементам.
    """
    global M, N, u, eps_dt_dx2, dt_2dx

    for m in range(M):
        for n in range(1, N):
            u[m+1, n] = u[m, n] + \
                        eps_dt_dx2 * (u[m, n+1] - 2*u[m, n] + u[m, n-1]) + \
                        dt_2dx * u[m, n] * (u[m, n+1] - u[m, n-1]) + \
                        dt * u[m, n]**3


#------------------------------------------------------------------
def fast_pde_solution():
    """
    Быстрая реализация "явной" разностной схемы - основана
    на использовании срезов вместо цикла по отдельным элементам.
    """
    global M, u, eps_dt_dx2, dt_2dx

    for m in range(M):
        u[m+1, 1:-1] = u[m, 1:-1] + \
                       eps_dt_dx2 * (u[m, 2:] - 2*u[m, 1:-1] + u[m, :-2]) + \
                       dt_2dx * u[m, 1:-1] * (u[m, 2:] - u[m, :-2]) + \
                       dt * u[m, 1:-1]**3


#------------------------------------------------------------------
# Начинаем выполнение программы:
#------------------------------------------------------------------

#------------------------------------------------------------------
# Шаг 0:
# Распарсим аргументы запуска программы.

parser = argparse.ArgumentParser(
            prog='python Example-08-0.py',
            description='Решение 1D ДУЧП параболического типа с использованием '
                        '"явной" разностной схемы без MPI параллелизации.',
)
parser.add_argument('-N', default=800,
                    help='Число `N` интервалов сетки по координате `x`. '
                         'По умолчанию равно 800.')
parser.add_argument('-M', default=100_000,
                    help='Число `M` интервалов сетки по времени `t`. '
                         'По умолчанию равно 100_000.')
parser.add_argument('-T', default=2.0,
                    help='Максимальное время `T`, до которого должны проводиться '
                         'расчёты. По умолчанию равно 2.0.')
parser.add_argument('--slow', action="store_true",
                    help='Использовать медленную реализацию решения, '
                         'с циклом по `n` при обновлении решения `u[m,n]` '
                         'вместо использования срезов `u[m,:]`.')
parser.add_argument('--save', action="store_true",
                    help='Сохранить результаты расчётов в файл '
                         '"Example-08-0_Results.npz".')

args = parser.parse_args()

#------------------------------------------------------------------
# Шаг 1:
# Задаём значения для всех констант, определяемых условиями задачи.
eps = 10**(-1.5)
a = 0.0; b = 1.0
t_0 = 0.0

T = float(args.T)
N = int(args.N)
M = int(args.M)

#------------------------------------------------------------------
# Шаг 2:
# Находим значения для всех вспомогательных констант.

# Начинаем реальные расчеты - включаем таймер:
start_time = time.perf_counter()

# Шаг по пространству:
dx = (b - a) / N

# Шаг по времени:
dt = (T - t_0) / M

# Константы для "быстрого" использования внутри разностной схемы:
eps_dt_dx2 = eps * dt / dx ** 2
dt_2dx = dt / (2 * dx)

# Массивы для хранения точек используемой сетки по пространству:
x = np.linspace(a, b, N+1)
# и по времени:
t = np.linspace(t_0, T, M+1)

#------------------------------------------------------------------
# Шаг 3:
# Задаём начальное и граничные условия.

# Будем хранить все насчитанные данные для создания анимации:
u = np.empty((M + 1, N + 1))

# Начальное условие:
u[0, :] = u_init(x)

# Граничные условия:
u[:, 0] = u_left(t)
u[:, N] = u_right(t)

# NOTE: Можно более педантично задавать граничные условия как
# u[1:, 0] = u_left(t[1:])
# u[1:, N] = u_right(t[1:])
# Но мы исходим из того, что начальные и граничные условия должны
# быть согласованы, то есть предполагаем, что выполняется условие:
# u_left(t0) == u_init(a) and u_right(t0) == u_init(b)

#------------------------------------------------------------------
# Шаг 4:
# Собственно, и сама нужная нам работа - решение нашего уравнения
# с помощью "явной" разностной схемы. По умолчанию, решаем уравнение
# быстро, но через переключатель '--slow' решаем медленно, как это
# было сделано в оригинальной версии программы. Сравните код обеих
# функций, `slow_pde_solution()` и `fast_pde_solution()`.

if args.slow:
    slow_pde_solution()
else:
    fast_pde_solution()

#------------------------------------------------------------------
# Шаг 5:
# Печатаем время выполнения и, если нужно, сохраняем результаты
# расчётов в файл "Example-08-0_Results.npz".

end_time = time.perf_counter()

print('Elapsed time is {:.4f} sec'.format(end_time-start_time))

# Если нужно, сохранить данные в файл:
if args.save:
    np.savez('Example-08-0_Results', x=x, t=t, u=u)

#------------------------------------------------------------------
