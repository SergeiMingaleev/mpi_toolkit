#------------------------------------------------------------------
# Пример 3.0: Последовательное решение системы линейных уравнений
#             методом сопряжённых градиентов.
#
# Задача: найти вектор x, являющийся решением системы линейных
#         уравнений A*x = b.
#
# Решение системы линейных уравнений A*x = b методом сопряжённых
# градиентов требует выполнения N итераций, где N - это размер
# вектора x. На каждой итерации мы будем обновлять значение
# вектора x в виде последовательности приближённых решений x_{s}
# на итерациях s от 1 до N+1.
#
# Чтобы начать итерации, нам нужно взять какое-то начальное
# приближение для x_{1} на первой итерации - но в целом, оно может
# быть любым, и обычно начинают с нулевого значения.
#
# Нам также понадобятся три вспомогательных вектора r, p, и q,
# значения которых также будут обновляться на каждой итерации s
# в виде последовательностей r_{s}, p_{s}, и q_{s}.
# Считаем при этом, что вектор p инициализирован нулём до начала
# итераций (то есть, для s=0).
#
# Тогда решение системы линейных уравнений может быть найдено
# методом сопряжённых градиентов по такому алгоритму:
#
#    x_{1} = 0 # или ваше приближение для решения!
#    p_{0} = 0
#    for s in range(1, N+1):
#        if s == 1:
#            r_{s} = dot(A.T, dot(A, x_{s}) - b)
#        else:
#            dot_pq = dot(p_{s-1}, q_{s-1})
#            r_{s} = r_{s-1} - q_{s-1} / dot_pq
#        dot_rr = dot(r_{s}, r_{s})
#        p_{s} = p_{s-1} + r_{s} / dot_rr
#        q_{s} = dot(A.T, dot(A, p_{s}))
#        dot_pq = dot(p_{s}, q_{s})
#        x_{s+1} = x_{s} - p_{s} / dot_pq
#
# После выполнения этого алгоритма, мы получим приближённое
# решение x_{N+1}, которое для случая квадратной матрицы A будет
# в действительности точным решением (с точностью до ошибок
# численного округления при выполнении арифметических операций).
#
# Размер матрицы A равен (M, N) - M строк и N колонок.
#
# Реализация самого метода сопряжённых градиентов вынесена в функцию
# `conjugate_gradient_method()` - остальная же часть кода занимается
# подготовкой данных и визуализацией решения.
#
#------------------------------------------------------------------
# Этот пример (в его оригинальном виде) детально обсуждается
# в начале лекции Д.В. Лукьяненко "3. Параллельная реализация метода
# сопряжённых градиентов":
# https://youtu.be/rQz7xov3_rU?list=PLcsjsqLLSfNCxGJjuYNZRzeDIFQDQ9WvC
#
# Объяснения математической части самого метода сопряжённых
# градиентов даются в лекциях Д.В. Лукьяненко:
# Лекция 9. Методы минимизации:
# https://teach-in.ru/lecture/2021-06-10-Lukyanenko
# Лекция 26. Интегральные уравнения
# https://teach-in.ru/lecture/2021-12-03-Lukyanenko
#
#------------------------------------------------------------------
# ВАЖНО ЗНАТЬ:
# Вышеописанная форма метода сопряжённых градиентов была впервые
# предложена в 2011 году российскими математиками в статье:
# Н.Н. Калиткин, Л. . Кузьмина, “Улучшенная форма метода сопряженных
# градиентов”, Матем. моделирование, 23:7 (2011), 33–51
# https://www.mathnet.ru/mm3129
#------------------------------------------------------------------

import numpy as np


#------------------------------------------------------------------
def conjugate_gradient_method(A, b, x, N):
    """
    Последовательное решение системы линейных уравнений A*x = b
    методом сопряжённых градиентов.

    :param A: Полная матрица `A`.
    :param b: Полный вектор `b`.
    :param x: Полный вектор `x`.
    :param N: Размер полного вектора `x`.

    :return: Приближённое (или точное, для квадратной матрицы) решение
             системы уравнений в виде полного вектора `x`.
    """

    # Сделаем "хранилища" для полных векторов `p`, `r`, и `q`
    # на всех процессах. Вектор `p` сразу инициализируем 
    # нулём (на итерации s=0):
    p = np.zeros(N, dtype=np.float64)
    r = np.empty(N, dtype=np.float64)
    q = np.empty(N, dtype=np.float64)

    # Чтобы сэкономить одно скалярное произведение векторов `p` и `q`
    # На каждой итерации, введём здесь временную переменную для него:
    dot_pq = 0.0
    
    # Цикл по итерациям s от 1 до N включительно:
    for s in range(1, N + 1):
        #------------------------------------------------------------
        # Шаг 1:
        # Обновим или создадим вектор `r`.
        if s == 1:
            # На первой итерации s=1, нужно создать вектор `r`:
            #   r_{s} = A.T.dot(A.dot(x_{s}) - b)
            r = np.dot(A.T, np.dot(A, x) - b)
        else:
            # На всех последующих итерациях, вектор `r` нужно просто
            # обновить:
            #    dot_pq = dot(p_{s-1}, q_{s-1})
            #    r_{s} = r_{s-1} - q_{s-1} / dot_pq

            # Важно, что скалярное произведение `dot(p_{s-1}, q_{s-1})`
            # мы уже вычислили в самом конце предыдущей итерации
            # и поместили его в переменную `dot_pq`, где оно до сих
            # пор ещё и хранится. Просто воспользуемся им для обновления `r`:
            r = r - q / dot_pq

        #------------------------------------------------------------
        # Шаг 2:
        # Обновим вектор `p`:
        #    dot_rr = dot(r_{s}, r_{s})
        #    p_{s} = p_{s-1} + r_{s} / dot_rr
        p = p + r / np.dot(r, r)

        #------------------------------------------------------------
        # Шаг 3:
        # Обновим вектор `q`: 
        #    q_{s} = A.T.dot(A.dot(p_{s}))
        q = np.dot(A.T, np.dot(A, p))

        #------------------------------------------------------------
        # Шаг 4:
        # Посчитаем скалярное произведение векторов dot(p, q): 
        #    dot_pq = dot(p_{s}, q_{s})

        # Запишем это скалярное произведение в переменную `dot_pq` - 
        # оно будет переиспользовано в начале цикла для обновления 
        # вектора `r`:
        dot_pq = np.dot(p, q)

        #------------------------------------------------------------
        # Шаг 5:
        # Обновим вектор `x`:
        #    x_{s+1} = x_{s} - p_{s} / dot_pq
        x = x - p / dot_pq

    return x


#------------------------------------------------------------------
# Начинаем выполнение программы:
#------------------------------------------------------------------

#------------------------------------------------------------------
# Шаг 1:
# Зачитаем из файла размер (M, N) матрицы A.

with open('Example-03_in.dat', 'r') as f1:
    M = np.array(np.int32(f1.readline()))
    N = np.array(np.int32(f1.readline()))

#------------------------------------------------------------------
# Шаг 2:
# Зачитаем из файла матрицу `A`.

A = np.empty((M, N), dtype=np.float64)

with open('Example-03_AData.dat', 'r') as f2:
    for j in range(M):
        for i in range(N):
            A[j,i] = np.float64(f2.readline())

#------------------------------------------------------------------
# Шаг 3:
# Зачитаем из файла вектор `b`.

b = np.empty(M, dtype=np.float64)

with open('Example-03_bData.dat', 'r') as f3:
    for j in range(M):
        b[j] = np.float64(f3.readline())

#------------------------------------------------------------------
# Шаг 5:
# Подготовим вектор `x`.

# ВАЖНО: если вы знаете хорошее начальное приближение для `x`,
# дайте его здесь!
x = np.zeros(N, dtype=np.float64)

#------------------------------------------------------------------
# Шаг 6:
# Собственно, и сама нужная нам работа - решение системы линейных
# уравнений итерационным методом сопряжённых градиентов:

x = conjugate_gradient_method(A, b, x, N)

#------------------------------------------------------------------
# Шаг 7:
# Окончательно, нарисуем посчитанный вектор `x`, используя
# библиотеку matplotlib.

# Для контроля, напечатаем найденное решение на консоли:
print(f"\nFinal solution:\nx = {x}")

# Подготовим рисунок и данные для него:
import matplotlib.pyplot as plt
plt.style.use('dark_background')
fig = plt.figure()
ax = plt.axes(xlim=(0, N), ylim=(-1.5, 1.5))
ax.set_xlabel('i'); ax.set_ylabel('x[i]')
# индексы элементов вектора `x`:
ii = np.arange(np.int32(N))
# Нарисуем полное решение:
ax.plot(ii, x, '-y', lw=3)
plt.show()

#------------------------------------------------------------------
